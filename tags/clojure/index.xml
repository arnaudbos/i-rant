<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arnaud Bos</title>
    <link>http://i-rant.arnaudbos.com/tags/clojure/index.xml</link>
    <description>Recent content on Arnaud Bos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="http://i-rant.arnaudbos.com/tags/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Water Pouring Problem in Clojure</title>
      <link>http://i-rant.arnaudbos.com/water-pouring-in-clojure/</link>
      <pubDate>Tue, 28 Nov 2017 06:23:11 +0100</pubDate>
      
      <guid>http://i-rant.arnaudbos.com/water-pouring-in-clojure/</guid>
      <description>
&lt;figure  &gt;
    
        &lt;img src=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/die-hard-3-water-puzzle.jpg&#34; alt=&#34;Caption of the water puzzle scene in Die Hard with a Vengeance&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h6&gt;&lt;em&gt;Die Hard with a Vengeance — Water puzzle scene&lt;/em&gt;&lt;/h6&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;hr /&gt;

&lt;p&gt;This post is the first or a series where I explore Clojure features
and start a discussion with my colleague &lt;a href=&#34;https://twitter.com/ilaborie&#34;&gt;Igor&lt;/a&gt; about &lt;a href=&#34;https://clojure.org/&#34;&gt;Clojure&lt;/a&gt;
and &lt;a href=&#34;https://kotlinlang.org/&#34;&gt;Kotlin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This summer, &lt;a href=&#34;https://twitter.com/ilaborie&#34;&gt;Igor&lt;/a&gt; offered to make a live Kotlin demo of a nice problem
he&amp;rsquo;s been &lt;a href=&#34;https://github.com/ilaborie/kotlin-pouring&#34;&gt;working on&lt;/a&gt; that can serve as a fine exercise to
discover and experiment a programming language: the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Water_pouring_puzzle&#34;&gt;Water pouring puzzle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article will talk about the &lt;strong&gt;&lt;em&gt;programming style&lt;/em&gt;&lt;/strong&gt; I&amp;rsquo;ve
used to find my solution: a data oriented, bottom-up approach, at the
REPL.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Igor&amp;rsquo;s &lt;a href=&#34;https://github.com/ilaborie/kotlin-pouring#guideline-try-to-implements-with-immutable-data-structure&#34;&gt;guideline&lt;/a&gt; offers a good starting point
on how OO and/or static typing (including myself when I switch to that mode,
when I do Java for instance) would solve this problem: model the world.&lt;br /&gt;
Notice how, by following this recipe, you don&amp;rsquo;t get to handle or transform
any data until point 15 of about 30.&lt;/p&gt;

&lt;p&gt;Although I understand how this is more usual, familiar and maybe the most
straightforward way to do things for a majority of developers, to me this is a
major drawback. It means that half of the time you are spending laying out
things, hoping the Lego blocks will fall into place, thinking about types and
safety when all you should be thinking about should be (IMO) how do I solve
this particular business domain.&lt;/p&gt;

&lt;p&gt;After a few years of &lt;a href=&#34;http://vvvvalvalval.github.io/posts/what-makes-a-good-repl.html&#34;&gt;REPL&lt;/a&gt; &lt;a href=&#34;https://vimeo.com/223309989&#34;&gt;driven development&lt;/a&gt; I
know that I have a good tool to functionally, expressively and
incrementally solve a problem.&lt;/p&gt;

&lt;p&gt;This post is basically a transcript of my thought process as I was writing
a solver to the Water pouring puzzle at the REPL.&lt;br /&gt;
It was interesting to take the time to reflect and watch myself work as
I was proceeding, it took more time but it was definitely an interesting
experiment.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I setup the boilerplate first. (leiningen, dependencies, etc) and a
namespace to work in:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(ns clojure-pouring.repl)

&lt;/div&gt;


&lt;p&gt;At the REPL, the fundamental principle is: &lt;strong&gt;&lt;em&gt;exploratory programming&lt;/em&gt;&lt;/strong&gt;.&lt;br /&gt;
I don&amp;rsquo;t know how to find the solution to this problem (yet!),
all I have at this point is a namespace.&lt;/p&gt;

&lt;p&gt;I must begin somewhere, so let&amp;rsquo;s start with some data: a glass has a total
capacity and a current state (&lt;code&gt;0&lt;/code&gt; by default), I need a collection of those.&lt;/p&gt;

&lt;p&gt;I start at the REPL by declaring &lt;code&gt;inital-state&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def initial-state
  [{:capacity 5
    :current 0}
   {:capacity 3
    :current 0}
   ])

initial-state

&lt;/div&gt;


&lt;p&gt;Then &lt;code&gt;final-state&lt;/code&gt; to illustrate the target:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def final-state
  [{:capacity 5
    :current 4}
   {:capacity 3
    :current 0}
   ])

final-state

&lt;/div&gt;


&lt;p&gt;Pretty easy: each glass is a &lt;code&gt;map&lt;/code&gt; and I put two of those in a &lt;code&gt;vector&lt;/code&gt;.&lt;br /&gt;
Just thinking about the amount of code I would have to write in Java or Kotlin
just to get a short sample of data like this gives me goosebumps.&lt;/p&gt;

&lt;p&gt;Kotlin &lt;a href=&#34;https://discuss.kotlinlang.org/t/plans-for-collection-literals/2049&#34;&gt;might&lt;/a&gt;,
at &lt;a href=&#34;https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/&#34;&gt;some point&lt;/a&gt;,
have collection literals similar to those, or not.&lt;br /&gt;
There seems to be a debate inside the community whether this is a desired
feature or not, despite the clear winner of the community survey.&lt;/p&gt;

&lt;p&gt;Communicating intent is an important part of a language and Kotlin&amp;rsquo;s debate
around collection literals seems to fall in the category of convenient syntax
vs intent. Why?&lt;br /&gt;
Because Kotlin&amp;rsquo;s designers have made the choice to support both mutable and
immutable collections as first class citizens. So how do you define what &lt;code&gt;{}&lt;/code&gt;
is or &lt;code&gt;[]&lt;/code&gt; is? Is it mutable or immutable?&lt;br /&gt;
The debate also seem to include considerations such as ordered/unordered and the
choice of syntax between lists and sets. Good luck figuring that out.&lt;/p&gt;

&lt;p&gt;Clojure is based on first-class persistent data-structures so mutation is not
and option, and its collection literals are easily identified:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt; for lists (PersistentList)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; for vectors (PersistentVector)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; for a maps (PersistentHashMap)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{}&lt;/code&gt; for sets (PersistentHashSet)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Want ordered/unordered variants? array-maps? queues? Sure, just use the
appropriate constructor, the collections you will use the most are available
as literals and it&amp;rsquo;s a burden not put on you, the developer.&lt;br /&gt;
View it as &lt;em&gt;&amp;ldquo;only convenient&amp;rdquo;&lt;/em&gt; if you want to ditch the argument and discussion
altogether, but with mutation out of the way a whole class of problems are gone
once again, and the benefit of being able to just copy and paste
around printed representations of data-structures (in REPL or in logs) and
use them verbatim as code is priceless.&lt;/p&gt;

&lt;p&gt;Alright, so the actions allowed to be performed on a glass are either to &lt;em&gt;pour&lt;/em&gt;
some quantity out of it, or to &lt;em&gt;fill&lt;/em&gt; it with some quantity.&lt;/p&gt;

&lt;p&gt;So I implement a &lt;code&gt;pour&lt;/code&gt; function first:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn pour
  ([glass]
   (assoc glass :current 0))
  ([glass quantity]
   (let [{:keys [current]} glass]
     (assoc glass :current (- current
                              (min current quantity))))))

&lt;/div&gt;


&lt;p&gt;This is a multi-arity function:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first implementation takes a glass as its only parameter and returns a
&lt;a name=&#34;anew&#34;&gt;&lt;/a&gt;new&lt;sup&gt;&lt;a href=&#34;#new&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; empty glass of the same capacity.&lt;/li&gt;
&lt;li&gt;The second implementation takes a glass as its first parameter and a quantity
as its second parameter and returns a new glass &lt;em&gt;poured out of&lt;/em&gt; the given
quantity or &lt;em&gt;poured out empty&lt;/em&gt; if it contains less than the given quantity.&lt;/li&gt;
&lt;li&gt;In the second arity, I &lt;em&gt;destructure&lt;/em&gt; the first parameter (the glass) which
is a map, in order to get its &lt;code&gt;current&lt;/code&gt; key only, as I don&amp;rsquo;t care about its
&lt;code&gt;capacity&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assoc&lt;/code&gt; is (&lt;a href=&#34;https://clojuredocs.org/clojure.core/assoc&#34;&gt;for short&lt;/a&gt;)
a standard library function that returns a new map containing the new
&lt;code&gt;key/value&lt;/code&gt; mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Don&amp;rsquo;t worry about the prefix notation, it&amp;rsquo;s not difficult, it&amp;rsquo;s just different,
you&amp;rsquo;re not
&lt;em&gt;&lt;a href=&#34;https://www.infoq.com/presentations/Simple-Made-Easy&#34;&gt;familiar&lt;/a&gt;&lt;/em&gt; with it, and
you&amp;rsquo;ll get used to it.&lt;/p&gt;

&lt;p&gt;Test &lt;code&gt;pour&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println (pour {:capacity 5 :current 4}))
(println (pour {:capacity 8 :current 4} 2))
(println (pour {:capacity 8 :current 4} 5))

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Pouring out empty a glass of capacity &lt;code&gt;5&lt;/code&gt; returns an empty glass of capacity
&lt;code&gt;5&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Pouring out &lt;code&gt;2&lt;/code&gt; from a glass of capacity &lt;code&gt;8&lt;/code&gt; containing &lt;code&gt;4&lt;/code&gt; returns
a glass of capacity &lt;code&gt;8&lt;/code&gt; containing &lt;code&gt;2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;And pouring out &lt;code&gt;5&lt;/code&gt; from a glass of capacity &lt;code&gt;8&lt;/code&gt; containing &lt;code&gt;4&lt;/code&gt; just returns
and empty glass, not &lt;code&gt;-1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ignore the last &lt;code&gt;nil&lt;/code&gt; in the results, it&amp;rsquo;s just the live code evaluation
plugin that prints it out as the result of the last &lt;code&gt;println&lt;/code&gt; call.&lt;br /&gt;
Go ahead and play with it a little, even change the implementation above
if you will.&lt;/p&gt;

&lt;p&gt;Now the &lt;code&gt;fill&lt;/code&gt; function:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn fill
  ([glass]
   (assoc glass :current (:capacity glass)))
  ([glass quantity]
   (let [{:keys [capacity current]} glass]
     (assoc glass :current (+ current
                              (min (- capacity current) quantity))))))

&lt;/div&gt;


&lt;p&gt;This is also a multi-arity function:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first implementation fills a glass up to its maximum capacity.&lt;/li&gt;
&lt;li&gt;The second implementation fills a glass &lt;em&gt;up to&lt;/em&gt; its maximum capacity given
a quantity to fill it with.&lt;/li&gt;
&lt;li&gt;Both return a new glass of course (not a copy!!!), we&amp;rsquo;re in &lt;strong&gt;&lt;em&gt;immutable&lt;/em&gt;&lt;/strong&gt;
land here.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Test &lt;code&gt;fill&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println (fill {:capacity 5 :current 0}))
(println (fill {:capacity 8 :current 4} 1))
(println (fill {:capacity 8 :current 7} 2))

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Filling an empty glass returns a glass full.&lt;/li&gt;
&lt;li&gt;Filling &lt;code&gt;1&lt;/code&gt; into a glass of capacity &lt;code&gt;8&lt;/code&gt; that already contains &lt;code&gt;4&lt;/code&gt; returns a
glass of capacity &lt;code&gt;8&lt;/code&gt; containing &lt;code&gt;5&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;And filling &lt;code&gt;2&lt;/code&gt; into a glass of capacity &lt;code&gt;8&lt;/code&gt; that already contains &lt;code&gt;7&lt;/code&gt; returns
a glass of capacity &lt;code&gt;8&lt;/code&gt; that is full, not &lt;code&gt;9&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;gallery&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;

  &lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/jug2.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;728x485&#34;&gt;
      &lt;img src=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/jug2.jpg&#34; itemprop=&#34;thumbnail&#34;
        
        
        width=&#34;390px&#34;
        height=&#34;142&#34;
        /&gt;
  &lt;/a&gt;

  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;

  &lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/jug3.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;728x485&#34;&gt;
      &lt;img src=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/jug3.jpg&#34; itemprop=&#34;thumbnail&#34;
        
        
        width=&#34;390px&#34;
        height=&#34;142&#34;
        /&gt;
  &lt;/a&gt;

  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;



&lt;/div&gt;


&lt;p&gt;Let&amp;rsquo;s take a break here.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;One of the major benefits of a good REPL (and Clojure&amp;rsquo;s REPL is a good one),
is the ability to explore: write one function at a time, execute it
&lt;strong&gt;right away&lt;/strong&gt; with a small amount of data, creating a really short
&lt;strong&gt;feedback loop&lt;/strong&gt; in order to &lt;strong&gt;explore&lt;/strong&gt; multiple solutions.&lt;/p&gt;

&lt;p&gt;In this blog post I use &lt;a href=&#34;https://github.com/viebel/klipse&#34;&gt;Klipse&lt;/a&gt; in order to present my iterative
process and &lt;strong&gt;let you play with the code&lt;/strong&gt;.&lt;br /&gt;
This is nice for you to get a feel and try different inputs to my functions,
or write different implementations if you want to.&lt;/p&gt;

&lt;p&gt;A good REPL is superior to TDD because it lets you write (or better: keep)
tests that matter, get the result out of a function call and use it again as
data that can populate your &lt;em&gt;real&lt;/em&gt; tests.&lt;/p&gt;

&lt;p&gt;But if you&amp;rsquo;ve tried other REPLs (ruby, python, node, etc.), you may be
thinking that a REPL is not practical, because it forces you to copy/paste
code all the time, go back and forth in you REPL&amp;rsquo;s history in order to
retrieve past results and implementations just to change a few characters.&lt;/p&gt;

&lt;p&gt;And this is where tooling is important.&lt;/p&gt;

&lt;p&gt;Lots of Clojure developers use emacs (or cursive, an Intellij plugin) and
benefit from its integration with the REPL.&lt;br /&gt;
I, personnally, have been enjoying &lt;a href=&#34;http://lighttable.com/&#34;&gt;Light Table&lt;/a&gt; since 2013, and
this is a screenshot of my laptop while I&amp;rsquo;m working at the REPL:&lt;/p&gt;

&lt;div class=&#34;gallery&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;

  &lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/screenshot.png&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1440x900&#34;&gt;
      &lt;img src=&#34;http://i-rant.arnaudbos.com/img/water-pouring-in-clojure/screenshot.png&#34; itemprop=&#34;thumbnail&#34;
        
        title=&#34;Light Table instaREPL&#34;
        width=&#34;100%&#34;
        height=&#34;142&#34;
        /&gt;
  &lt;/a&gt;

  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;div class=&#34;title&#34;&gt;Light Table instaREPL&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Do you see the &amp;ldquo;blue&amp;rdquo; data? This is the result of evaluating a Clojure
expression in the editor itself.&lt;br /&gt;
This alone has made it difficult for me to switch to another editor ever since.&lt;/p&gt;

&lt;p&gt;At the REPL, I type in &lt;strong&gt;data&lt;/strong&gt;, I pass it to &lt;strong&gt;functions&lt;/strong&gt; and I get the
&lt;strong&gt;result&lt;/strong&gt; (which I use later as new input/expected output for other tests)
in front of my eyes.&lt;br /&gt;
I define &lt;strong&gt;new functions&lt;/strong&gt; and make extensive use of &lt;em&gt;&amp;ldquo;variable shadowing&amp;rdquo;&lt;/em&gt; to
&lt;strong&gt;modify the implementation of existing functions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;No classes, no types, no FactoryFactoryAbstractDelegateProxyPattern:
just data and functions&amp;hellip;&lt;br /&gt;
I can hear you, static typing addict: &lt;strong&gt;BUT IT IS NOT SAFE!&lt;/strong&gt;&lt;br /&gt;
Yes, I know, I just don&amp;rsquo;t care at this point! I told you, I&amp;rsquo;m &lt;strong&gt;exploring&lt;/strong&gt;.
I want to go fast, iterate quickly, not model the whole universe and bang my
head against the type checker.&lt;/p&gt;

&lt;p&gt;I can just rely on my tests for now and use simple assertions or
&lt;a href=&#34;https://clojure.org/about/spec&#34;&gt;specifications&lt;/a&gt; later (or now, but right now
I&amp;rsquo;m not, obviously) to refine.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve never had a shortest feedback loop in any other language I&amp;rsquo;ve used, this is
pure gold.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s continue our problem solving.&lt;/p&gt;

&lt;p&gt;I have a pouring and a filling function.&lt;br /&gt;
Now I&amp;rsquo;d need a function that takes a collection of glasses (state),
apply an action (commonly called a &amp;lsquo;move&amp;rsquo; in the current domain language)
and return a new, updated collection of glasses (new state).&lt;/p&gt;

&lt;p&gt;What characterizes a move? It&amp;rsquo;s either an &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;pour&lt;/code&gt; or &lt;code&gt;fill&lt;/code&gt; action
associated with glass indices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;empty &lt;code&gt;from&lt;/code&gt; the nth glass&lt;/li&gt;
&lt;li&gt;fill &lt;code&gt;to&lt;/code&gt; the nth glass&lt;/li&gt;
&lt;li&gt;pour &lt;code&gt;from&lt;/code&gt; the mth glass &lt;code&gt;to&lt;/code&gt; the nth glass&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Expressivity matters, so maybe a move would be best represented by a map.&lt;br /&gt;
A map with a type that characterizes the move (&lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;fill&lt;/code&gt;, &lt;code&gt;pour&lt;/code&gt;) and
subjects that indicate the source / target / both of the move (&lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println &#34;Empty glass 0:&#34; {:type :empty :from 0})
(println &#34;Fill glass 1:&#34; {:type :fill :to 1})
(println &#34;Pour glass 1 into glass 0:&#34; {:type :pour :from 1 :to 0})

&lt;/div&gt;


&lt;p&gt;I&amp;rsquo;m beginning to think that a bit of &lt;em&gt;Ad-hoc polymorphism&lt;/em&gt; would
be great in order to dispatch on the type of move: let&amp;rsquo;s use
&lt;em&gt;multimethods&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defmulti -&gt;move
  &#34;Apply a move to the given state and return the new state.&#34;
  (fn [state move] (:type move)))

&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;defmulti&lt;/code&gt; macro defines a new multimethod with the associated
&lt;code&gt;dispatch function&lt;/code&gt;.&lt;br /&gt;
Which means that the &lt;code&gt;-&amp;gt;move&lt;/code&gt; function will take two parameters, and the
dispatch function will &lt;em&gt;choose&lt;/em&gt; the appropriate implementation.&lt;/p&gt;

&lt;p&gt;In this case I dispatch based on the value associated to the &lt;code&gt;:type&lt;/code&gt; key in the
&lt;code&gt;move&lt;/code&gt; parameter.&lt;br /&gt;
A &lt;code&gt;:empty&lt;/code&gt; move will dispatch to the &lt;code&gt;-&amp;gt;move :empty&lt;/code&gt; multimethod.&lt;br /&gt;
A &lt;code&gt;:fill&lt;/code&gt; move will dispatch to the &lt;code&gt;-&amp;gt;move :fill&lt;/code&gt; multimethod.&lt;br /&gt;
A &lt;code&gt;:pour&lt;/code&gt; move will dispatch to the &lt;code&gt;-&amp;gt;move :pour&lt;/code&gt; multimethod.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
; Empty the glass at index from
(defmethod -&gt;move :empty
  [state {:keys [from]}]
  (update-in state [from] pour))

; Fill the glass at index to
(defmethod -&gt;move :fill
  [state {:keys [to]}]
  (update-in state [to] fill))

; Pour the glass at index from into the glass at index to
(defmethod -&gt;move :pour
  [state {:keys [from to]}]
  (let [quantity (min (get-in state [from :current])
                      (- (get-in state [to :capacity])
                         (get-in state [to :current])))]
    (-&gt; state
        (update-in [from] pour quantity)
        (update-in [to] fill quantity))))

&lt;/div&gt;


&lt;p&gt;&lt;code&gt;update-in&lt;/code&gt; is a &lt;a href=&#34;https://clojuredocs.org/clojure.core/update-in&#34;&gt;standard library&lt;/a&gt;
function that takes a data structure as a first parameter and &amp;ldquo;updates&amp;rdquo;
(immutable, remember?) the value nested at the path given by the second
parameter by applying to it the function supplied as the third parameter&amp;hellip;&lt;br /&gt;
Don&amp;rsquo;t pretend you didn&amp;rsquo;t understand, just reread carefully.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take our &lt;code&gt;-&amp;gt;move :empty&lt;/code&gt; multimethod as an example.&lt;br /&gt;
Since our move is an &lt;code&gt;:empty&lt;/code&gt;, we destructure this parameter to get the
value at the &lt;code&gt;:from&lt;/code&gt; key: the index of the glass in &lt;code&gt;state&lt;/code&gt; that we want to
empty.&lt;br /&gt;
Once the glass has been fetched, &lt;code&gt;update-in&lt;/code&gt; will evaluate the &lt;code&gt;pour&lt;/code&gt; function
with the glass as its sole parameter.&lt;br /&gt;
Since I&amp;rsquo;ve implemented the 1-arity of the &lt;code&gt;pour&lt;/code&gt; function so that it just
returns a new empty glass of same capacity, this result will &lt;em&gt;replace&lt;/em&gt;
the glass in the &lt;code&gt;state&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s test &lt;code&gt;-&amp;gt;move&lt;/code&gt; to &amp;ldquo;manually&amp;rdquo; go from &lt;code&gt;initial-state&lt;/code&gt; to &lt;code&gt;final-state&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(-&gt; initial-state
    (-&gt;move {:type :fill :to 1})
    (-&gt;move {:type :pour :from 1 :to 0})
    (-&gt;move {:type :fill :to 1})
    (-&gt;move {:type :pour :from 1 :to 0})
    (-&gt;move {:type :empty :from 0})
    (-&gt;move {:type :pour :from 1 :to 0})
    (-&gt;move {:type :fill :to 1})
    (-&gt;move {:type :pour :from 1 :to 0})
    )

&lt;/div&gt;


&lt;p&gt;It works!&lt;/p&gt;

&lt;p&gt;I must now implement a function that, when given a collection of glasses,
returns a collection of possible moves that can be applied to this state in
order to produce a &lt;em&gt;meaningful&lt;/em&gt; new collection of glasses.&lt;/p&gt;

&lt;p&gt;Meaningful as in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;not emptying an empty glass,&lt;/li&gt;
&lt;li&gt;not filling a glass that is full, and&lt;/li&gt;
&lt;li&gt;not pouring into &amp;lsquo;itself&amp;rsquo;, which gets us nowhere&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn glasses-&gt;index
  &#34;Filter the glasses by the filter-fn function and
  return the index the filtered item had in the
  glasses collection.&#34;
  [glasses filter-fn]
  (-&gt;&gt; glasses
       (map-indexed #(vector %1 %2))
       (filter (fn [[idx value]] (filter-fn value)))
       (map first)))

&lt;/div&gt;


&lt;p&gt;I&amp;rsquo;m not going to explain everything, just look at the input and output in this
test of &lt;code&gt;glasses-&amp;gt;index&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println &#34;Indices of non-empty glasses:&#34;
         (glasses-&gt;index final-state (comp pos? :current)))
(println &#34;Indices of glasses of capacity 3:&#34;
         (glasses-&gt;index final-state (comp #(= 3 %) :capacity)))

&lt;/div&gt;


&lt;p&gt;The &lt;em&gt;&amp;ldquo;indexing&amp;rdquo;&lt;/em&gt; works, now the function for listing moves:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn available-moves
  &#34;Return the list of valid moves from current state of glasses.&#34;
  [glasses]
  (let [non-empty (glasses-&gt;index glasses (comp pos? :current))
        non-full (glasses-&gt;index glasses #(&lt; (:current %) (:capacity %)))]
    (concat
      (map #(hash-map :type :empty :from %) non-empty)
      (map #(hash-map :type :fill  :to   %) non-full)
      ; I really like this one
      (for [from non-empty to non-full :when (not= from to)]
        {:type :pour :from from :to to}))))

&lt;/div&gt;


&lt;p&gt;Concatenate the list of moves able to empty the non-empty glasses, fill the
non-full glasses and pour the non-empty glasses into the distinct non-full
glasses.&lt;/p&gt;

&lt;p&gt;Test &lt;code&gt;available-moves&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println (available-moves initial-state))
(println (available-moves final-state))

&lt;/div&gt;


&lt;p&gt;I can get the list of moves that are practicable, now let&amp;rsquo;s
explore the next glasses available from the current glasses.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn explore
  [glasses moves]
  (map (partial -&gt;move glasses) moves))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;explore&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(explore initial-state (available-moves initial-state))

&lt;/div&gt;


&lt;p&gt;Given a list of glasses (a state), returns the list of glasses I could get to
(next states) by applying the moves that are available from my current state.&lt;/p&gt;

&lt;a class=&#34;fold title&#34; onclick=&#34;$(&#39;#explore&#39;).toggleClass(&#39;hidden&#39;);&#34;&gt;[Exploration]&lt;/a&gt;
&lt;div id=&#34;explore&#34; class=&#34;fold content hidden&#34;&gt;
  &lt;p&gt;I won&amp;rsquo;t need this function because in order to find the list of moves
leading from a state to another I must keep the previous moves in memory when
exploring further&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;explore&lt;/code&gt; is not enough, but at least I know how to explore the spectrum
of all the possible next states for a given state and list of moves.&lt;/p&gt;

&lt;p&gt;See? I&amp;rsquo;ve &lt;em&gt;explored&lt;/em&gt;, I&amp;rsquo;ve made an experiment with a function mapped over
some data. And it didn&amp;rsquo;t cost much because my feedback loop is really short.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve realized this path is not going to help, so I can just discard it and
refine my understanding of the steps I need to take to reach my goal.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Given a &lt;code&gt;node&lt;/code&gt; containing glasses and the sequence of moves leading to
them, return a list of successor nodes.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn expand
  [{:keys [glasses moves] :as node}]
  (let [next-moves (available-moves glasses)]
    (map #(hash-map :glasses (-&gt;move glasses %)
                    :moves (conj moves %))
         next-moves)))

&lt;/div&gt;


&lt;p&gt;I evaluate the moves available from the current node&amp;rsquo;s glasses and for each
one of them I return a new node consisting of the next state of glasses and
the augmented list of move leading to it.&lt;/p&gt;

&lt;p&gt;Test &lt;code&gt;expand&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println
  (expand
    {:glasses [{:capacity 5 :current 5} {:capacity 3 :current 0}]
     :moves [{:type :fill :to 0}]}))

&lt;/div&gt;


&lt;p&gt;Nice, given glasses and the &lt;code&gt;history&lt;/code&gt; of moves that led from an initial
state to these glasses, I can get the list of next states that are
&lt;em&gt;possible&lt;/em&gt;, with their respective history of moves.&lt;/p&gt;

&lt;p&gt;But at some point I might reach a state that I have already visited in the
past&amp;hellip; So it would be interesting to keep an index of the states that I
have already visited in order to query it and avoid useless computation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s &lt;em&gt;&amp;ldquo;backtract&amp;rdquo;&lt;/em&gt; the already visited nodes:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn backtrack
  &#34;Returns true if a node has been visited.&#34;
  [visited {:keys [glasses]}]
  (not (contains? visited glasses)))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;backtrack&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(backtrack #{[{:capacity 5 :current 0} {:capacity 3 :current 0}]}
           {:glasses [{:capacity 5 :current 5} {:capacity 3 :current 0}]
            :moves [{:type :fill :to 0}]})

&lt;/div&gt;


&lt;p&gt;The first parameter of &lt;code&gt;backtrack&lt;/code&gt; is a set, so &lt;code&gt;contains?&lt;/code&gt; is &lt;code&gt;O(1)&lt;/code&gt;, not
&lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m almost there, right?&lt;br /&gt;
But I must stop searching at some point, so let&amp;rsquo;s identify a solution among
a set of candidates:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn has-solution?
  [target successors]
  (some #(when (= target (:glasses %)) (:moves %))
        successors))

&lt;/div&gt;


&lt;p&gt;&lt;code&gt;some&lt;/code&gt; is a &lt;a href=&#34;https://clojuredocs.org/clojure.core/some&#34;&gt;standard library&lt;/a&gt;
function that returns the first logical true value of the predicate function
result.&lt;br /&gt;
My predicate function returns the list of moves leading to the current node
when the glasses of the node match the target glasses state, so if the
&lt;code&gt;successors&lt;/code&gt; collection contains the solution, the list of moves to get
there is returned.&lt;/p&gt;

&lt;p&gt;Test &lt;code&gt;has-solution?&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(println &#34;Does not have solution:&#34;
  (has-solution?
    [{:capacity 5 :current 4} {:capacity 3 :current 0}]
    []))

(println &#34;The solution (list of moves) is:&#34;
  (has-solution?
    [{:capacity 5 :current 4} {:capacity 3 :current 0}]
    [{:glasses [{:capacity 5 :current 0}] :moves []}
     {:glasses [{:capacity 5 :current 4} {:capacity 3 :current 0}] :moves [:foo :bar]}]))

&lt;/div&gt;


&lt;p&gt;And now the final part: I must compose the functions I have written so far
in order to implement a solver.&lt;/p&gt;

&lt;p&gt;This is &lt;em&gt;bottom-up&lt;/em&gt;. I know I have all the parts of my solver in place and
I have tested most of them along the way.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s loop over glasses nodes, keeping track of the already visited ones,
searching for a solution leading to the target state:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(require &#39;[clojure.set :as set])

(defn solver
  &#34;Given a target state, returns a function that will solve the water pouring
  problem for an initial state&#34;
  [target]
  (let [has-solution-fn? (partial has-solution? target)]
    (fn [glasses]
      ; Start with an empty set of visited states and an empty list of moves
      (loop [visited #{} nodes [{:glasses glasses :moves []}]]
        (if-let [solution (has-solution-fn? nodes)]
          solution
          (let [successors (mapcat #(expand %) nodes)
                valid-successors (filter (partial backtrack visited) successors)
                newly-visited (into #{} (map :glasses valid-successors))]
            (recur (clojure.set/union visited newly-visited)
                   valid-successors)))))))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;solver&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def simple-solver
  (solver [{:capacity 5 :current 4}
           {:capacity 3 :current 0}]))

(simple-solver [{:capacity 5 :current 0}
                {:capacity 3 :current 0}])

&lt;/div&gt;


&lt;p&gt;Test it again with a (seemingly) more complicated use case:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def less-simple-solver
  (solver [{:capacity 8 :current 4}
           {:capacity 5 :current 0}
           {:capacity 3 :current 0}]))

(less-simple-solver [{:capacity 8 :current 0}
                     {:capacity 5 :current 0}
                     {:capacity 3 :current 0}])

&lt;/div&gt;


&lt;hr /&gt;

&lt;p&gt;Functionally I could stop here because the problem is solved. But there are
some points that bother me, some &lt;code&gt;vars&lt;/code&gt; names that don&amp;rsquo;t reflect what
piece of information they carry or some functions that could be broken into
smaller ones.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s refactor a little:&lt;/p&gt;

&lt;p&gt;Refactor &lt;code&gt;-&amp;gt;move&lt;/code&gt; to better reflect domain:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defmulti -&gt;move
  &#34;Apply a move to the given state and return the new state.&#34;
  (fn [glasses move] (:type move)))

(defmethod -&gt;move :empty
  [glasses {:keys [from]}]
  (update-in glasses [from] pour))

(defmethod -&gt;move :fill
  [glasses {:keys [to]}]
  (update-in glasses [to] fill))

(defmethod -&gt;move :pour
  [glasses {:keys [from to]}]
  (let [quantity (min (get-in glasses [from :current])
                      (- (get-in glasses [to :capacity])
                         (get-in glasses [to :current])))]
    (-&gt; glasses
        (update-in [from] pour quantity)
        (update-in [to] fill quantity))))

&lt;/div&gt;


&lt;p&gt;Refactor &lt;code&gt;expand&lt;/code&gt; by extracting the node builder:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn make-node
  [glasses moves]
  {:glasses glasses
   :moves moves})

(defn expand-node
  [{:keys [glasses moves]}]
  (let [next-moves (available-moves glasses)]
    (-&gt;&gt; next-moves
         (map #(make-node (-&gt;move glasses %) (conj moves %))))))

&lt;/div&gt;


&lt;p&gt;Refactor &lt;code&gt;solver&lt;/code&gt; by decomposing functions:&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a &lt;code&gt;make-glass&lt;/code&gt; utility function:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn make-glass
  ([capacity]
   (make-glass capacity 0))
  ([capacity current]
   {:capacity capacity :current current}))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;make-glass&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(make-glass 5)

&lt;/div&gt;


&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(make-glass 8 3)

&lt;/div&gt;


&lt;p&gt;Now a &lt;code&gt;initialize&lt;/code&gt; function to create a vector of glasses from capacities or
capacities + quantities:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn initialize
  ([capacities]
   (vec (map make-glass capacities)))
  ([capacities quantities]
   (vec (map make-glass capacities quantities))))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;initialize&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(initialize [8 5 3])

&lt;/div&gt;


&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(initialize [8 5 3] [4 0 0])

&lt;/div&gt;


&lt;p&gt;Let&amp;rsquo;s extract the part of the solver that find the successors of a collection
of nodes into &lt;code&gt;find-successors&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn find-successors
  [nodes]
  (mapcat #(expand-node %) nodes))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;find-successors&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(find-successors [{:glasses [{:capacity 5 :current 0} {:capacity 3 :current 0}] :moves []}])

&lt;/div&gt;


&lt;p&gt;Let&amp;rsquo;s extract the part of the solver that filters out the successors that have
already been visited into &lt;code&gt;filter-successors&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn filter-successors
  [successors visited]
  (filter (partial backtrack visited) successors))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;filter-successors&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(filter-successors
  [{:moves [{:type :fill :to 0}] :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}
   {:moves [{:type :fill, :to 1}], :glasses [{:capacity 5, :current 0} {:capacity 3, :current 3}]}]
  #{[{:capacity 5, :current 5} {:capacity 3, :current 0}]})

&lt;/div&gt;


&lt;p&gt;We&amp;rsquo;re almost done. Let&amp;rsquo;s create a function to only keep a distinct set of
successors from a collection of candidates with &lt;code&gt;get-unique-glasses&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn distinct-glasses
  [successors]
  (into #{} (map :glasses successors)))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;distinct-glasses&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(distinct-glasses
  [{:moves [{:type :fill :to 0}] :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}
   {:moves [{:type :fill, :to 1}], :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}])

&lt;/div&gt;


&lt;p&gt;And now we can rewrite &lt;code&gt;solver&lt;/code&gt; with these new pieces.&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn solver
  [capacities quantities]
  (let [initial (initialize capacities)
        target (initialize capacities quantities)
        has-solution-fn? (partial has-solution? target)]
    (fn []
      (let [first-node (make-node initial [])]
        (loop [visited #{initial} nodes [first-node]]
          (if-let [solution (has-solution-fn? nodes)]
            solution
            (let [successors (find-successors nodes)
                  valid-successors (filter-successors successors visited)
                  unique-glasses (distinct-glasses valid-successors)]
              (recur (clojure.set/union visited unique-glasses)
                     valid-successors))))))))

&lt;/div&gt;


&lt;p&gt;Test &lt;code&gt;solver&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def simple-solver (solver [5 3] [4 0]))
(println (simple-solver))

&lt;/div&gt;


&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(def less-simple-solver (solver [8 5 3] [4 0 0]))
(println (less-simple-solver))

&lt;/div&gt;


&lt;p&gt;Implement &lt;code&gt;-main&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  
(defn -main
  [&amp; args]
  (assert (even? (count args)))
  (let [input (map #(Integer. (re-find  #&#34;\d+&#34; %)) args)
        solver-fn (apply solver (split-at (/ (count input) 2) input))]
    (println (solver-fn))))

&lt;/div&gt;


&lt;hr /&gt;

&lt;p&gt;It&amp;rsquo;s been a pretty long article in the end. Together we&amp;rsquo;ve implemented a
function to solve the water pouring problem for an arbitrary list of glasses
of some quantity in Clojure.&lt;/p&gt;

&lt;p&gt;You can find the file I&amp;rsquo;ve used to write this exploratory work
&lt;a href=&#34;https://github.com/arnaudbos/clj-water-pouring/blob/master/src/clj_water_pouring/repl.clj&#34;&gt;here&lt;/a&gt;, and the final version of the solver without
all the evaluations &lt;a href=&#34;https://github.com/arnaudbos/clj-water-pouring/blob/master/src/clj_water_pouring/core.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The thing that is the most interesting to me here is not the number of lines,
the safety or the provability of correctness.&lt;br /&gt;
What I want to stress out is the development at the REPL.&lt;/p&gt;

&lt;p&gt;You can see in the repository that I didn&amp;rsquo;t even bother to write tests, because
I don&amp;rsquo;t plan to share this work, publish it or maintain it. Nonetheless it has
been tested.&lt;br /&gt;
I has been tested all the way from the beginning, at each function definition,
with data. You see, I didn&amp;rsquo;t need to use TDD, and I didn&amp;rsquo;t have to write some
temporary &lt;code&gt;main&lt;/code&gt; function to pass inputs to the command line, and I didn&amp;rsquo;t need
to wait until I&amp;rsquo;ve assembled all the code together to try it fingers crossed.&lt;/p&gt;

&lt;p&gt;Through the use of immutability, pure functions and first-class data literals
I feel like I can achieve more and iterate more quickly than with any other
language I&amp;rsquo;ve used.&lt;br /&gt;
I also argue that the Lisp syntax, although different, is an asset, because
there&amp;rsquo;s no cognitive load associated with it: no magical keywords, no mix of
parents, braces or brackets for structure: just lists as functions and data.&lt;/p&gt;

&lt;p&gt;Footnote:&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;new&#34;&gt;1&lt;/a&gt;: This it is not exactly a new glass as in &amp;lsquo;a copy&amp;rsquo; but a
new pointer to a persistent data structure, a concept also know as
&lt;em&gt;structural sharing&lt;/em&gt; (&lt;a href=&#34;#anew&#34;&gt;go back&lt;/a&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Feedback on giving a talk</title>
      <link>http://i-rant.arnaudbos.com/feedback-on-giving-a-talk/</link>
      <pubDate>Mon, 20 Nov 2017 03:09:02 +0100</pubDate>
      
      <guid>http://i-rant.arnaudbos.com/feedback-on-giving-a-talk/</guid>
      <description>&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;OMW to my first ever local meetup talk. I will be presenting &lt;a href=&#34;https://twitter.com/hashtag/Clojure?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Clojure&lt;/a&gt;.&lt;br&gt;/me nervous as fuck &lt;a href=&#34;https://t.co/sFqpDa0Iqz&#34;&gt;pic.twitter.com/sFqpDa0Iqz&lt;/a&gt;&lt;/p&gt;&amp;mdash; Arnaud Bos (@arnaud_bos) &lt;a href=&#34;https://twitter.com/arnaud_bos/status/928664706222575616?ref_src=twsrc%5Etfw&#34;&gt;November 9, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;p&gt;Last week I gave a talk at a local meetup, the Toulouse Java User Group,
where I presented Lisp and Clojure.&lt;/p&gt;

&lt;p&gt;Apart from mandatory workgroup presentations or master thesis defense, I&amp;rsquo;ve
never volunteered to talk in front of people.&lt;/p&gt;

&lt;p&gt;In the beginning of May 2017, I sent a &amp;ldquo;Call for paper&amp;rdquo; to one of our local
&lt;a href=&#34;https://devfesttoulouse.fr/&#34;&gt;GDG DevFest&lt;/a&gt; and got rejected ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/p&gt;

&lt;p&gt;My presentation title wasn&amp;rsquo;t entertaining, the content was pretty boring and
I also left my speaker bio empty because I forgot to submit it.&lt;br /&gt;
Honestly, now that I think about it I would have rejected myself. But at
the time it was disappointing, and also relieving.&lt;/p&gt;

&lt;p&gt;And then, during the summer I listened to
&lt;a href=&#34;https://www.functionalgeekery.com/episode-82-mohit-thatte/&#34;&gt;this episode of Functional Geekery&lt;/a&gt; in which
&lt;a href=&#34;https://twitter.com/mohitthatte&#34;&gt;Mohit Thatte&lt;/a&gt; explains how he has created a
&lt;a href=&#34;http://inclojure.org&#34;&gt;Clojure conference in India&lt;/a&gt; and essentially says that you get
the community you deserve and if no-one has created a meetup yet, you can
just start with that, it doesn&amp;rsquo;t have to be someone else to do it.&lt;/p&gt;

&lt;p&gt;But creating a meetup first and then try to spread the word about it and
convince people to come is not something I could do, so I made a new
proposal to a talk about Clojure at our local Java User Group.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.toulousejug.org/&#34;&gt;Toulouse Java User Group&lt;/a&gt; has a good aura and is one of the
most frequently and well organized user group in town, so I decided to
reword my presentation proposal and found a provocative title:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The greatest single programming language ever designed: Lisp on the JVM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a quote by &lt;a href=&#34;https://en.wikipedia.org/wiki/Alan_Kay&#34;&gt;Alan Kay&lt;/a&gt; and I was expecting a lot of trolls,
obviously.&lt;/p&gt;

&lt;p&gt;Preparing the talk has been exhausting because I was terrified at the idea
of not being able to express my ideas or answering questions about my topic.&lt;br /&gt;
This is why I read &lt;a href=&#34;https://www.manning.com/books/clojure-in-action-second-edition&#34;&gt;two&lt;/a&gt; &lt;a href=&#34;https://www.manning.com/books/the-joy-of-clojure-second-edition&#34;&gt;books&lt;/a&gt;, watched and read
several dozens of talks and articles about Clojure but also about a dozen of
articles about the concepts of &lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_and_change&#34;&gt;Identity and change&lt;/a&gt;, plus a
mini series of really interesting (French) &lt;a href=&#34;https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin&#34;&gt;podcast&lt;/a&gt; (episodes more or
less related to the concept of &amp;ldquo;time&amp;rdquo;, from Sept. 2, 2017 to Oct. 21, 2017).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve read so much that I didn&amp;rsquo;t take the time necessary to review and memorize
my talk&amp;hellip;&lt;br /&gt;
I you take &lt;a href=&#34;https://waitbutwhy.com/2016/03/doing-a-ted-talk-the-full-story.html&#34;&gt;Tim Urban&amp;rsquo;s &amp;ldquo;Methods&amp;rdquo;&lt;/a&gt;, I was at level &amp;ldquo;3B&amp;rdquo; which,
according to him, is the worst place to be:&lt;/p&gt;


&lt;figure  &gt;
    
        &lt;img src=&#34;http://i-rant.arnaudbos.com/img/feedback-on-giving-a-talk/method.png&#34; alt=&#34;Tim Urban Public Speaking Methods Pros and Cons&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;The night before the talk I was polishing my slides and &lt;strong&gt;practicing in front of
my fridge, at 2am, in my pyjamas, while my wife and children where peacefully
asleep&lt;/strong&gt;. I was so &lt;em&gt;frightened&lt;/em&gt; that I considered dozens of excuses and possible
ways to &lt;em&gt;avoid giving the talk&lt;/em&gt;.&lt;br /&gt;
After a short night I did realize not getting enough sleep was a terrible idea.&lt;/p&gt;

&lt;p&gt;The rest of the day has been a cycle going from totally relaxed, to nervous
as fuck, until it was my time to talk to the audience.&lt;/p&gt;

&lt;p&gt;As soon as I begun to talk I felt like the stress was &lt;em&gt;melting away&lt;/em&gt;. I was
still nervous of course, but a big part of it was gone just by going on stage
and doing the actual thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Giving the talk was a tremendous experience and the distress preceding it
was immediately replaced by a feeling of completeness, gratitude and love.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Despite my &amp;ldquo;3B public speaking method&amp;rdquo; I don&amp;rsquo;t actually think the talk was
boring as most of the people were active during my presentation, answering
questions and laughing (when expected to).&lt;/p&gt;

&lt;p&gt;But as a first time speaker I&amp;rsquo;ve made a lot of mistakes both before and during
the presentation. &lt;em&gt;I know it, because I watched the video&lt;/em&gt; later on. And
&lt;strong&gt;watching myself was horrible experience&lt;/strong&gt;&amp;hellip;&lt;/p&gt;

&lt;div class=&#34;gallery&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;

  &lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://i-rant.arnaudbos.com/img/feedback-on-giving-a-talk/left.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;2048x1324&#34;&gt;
      &lt;img src=&#34;http://i-rant.arnaudbos.com/img/feedback-on-giving-a-talk/left.jpg&#34; itemprop=&#34;thumbnail&#34;
        
        
        width=&#34;395&#34;
        height=&#34;142&#34;
        /&gt;
  &lt;/a&gt;

  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;

  &lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://i-rant.arnaudbos.com/img/feedback-on-giving-a-talk/right.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;2048x1324&#34;&gt;
      &lt;img src=&#34;http://i-rant.arnaudbos.com/img/feedback-on-giving-a-talk/right.jpg&#34; itemprop=&#34;thumbnail&#34;
        
        
        width=&#34;395&#34;
        height=&#34;142&#34;
        /&gt;
  &lt;/a&gt;

  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;div class=&#34;title&#34;&gt;Presenting Clojure at the Java User Group&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Seriously, it&amp;rsquo;s a lot worse than just hearing the sound of your voice and being
like:&lt;br /&gt;
&lt;em&gt;&amp;ldquo;I sound like a duck.&amp;rdquo;&lt;/em&gt;&lt;br /&gt;
The video adds a new dimension to it and you notice every single detail that
is wrong about your body, &amp;ldquo;look&amp;rdquo; or attitude.&lt;/p&gt;

&lt;p&gt;Nonetheless, I now understand what people say when they talk about about
public speaking and the desire to get back to it as soon as you&amp;rsquo;ve finished
the last one.&lt;br /&gt;
The feeling of &lt;em&gt;hopelessness and nervousness&lt;/em&gt; during the preparation, followed
by the &lt;em&gt;relief and well being&lt;/em&gt; done with it are separated only by an ephemeral
moment where you physically and mentally engage in a single activity.&lt;br /&gt;
&lt;strong&gt;This is all hormones and brain chemistry&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I hope this will encourage other people who might want to start giving
presentations to actually &lt;a href=&#34;https://www.youtube.com/watch?v=os6U77Hhm_s&#34;&gt;do it&lt;/a&gt;. Honestly, it&amp;rsquo;s worth it, even if you feel like
shit when preparing and also after watching yourself on video afterwards.
If people like what you have to say, they will tell you, and getting
congratulations for spreading ideas you care about is the biggest reward.&lt;br /&gt;
That and dopamine, you &lt;em&gt;junkie&lt;/em&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Happy birthday Clojure!</title>
      <link>http://i-rant.arnaudbos.com/happy-birthday-clojure/</link>
      <pubDate>Mon, 13 Nov 2017 13:50:14 +0100</pubDate>
      
      <guid>http://i-rant.arnaudbos.com/happy-birthday-clojure/</guid>
      <description>
&lt;figure  &gt;
    
        &lt;img src=&#34;http://i-rant.arnaudbos.com/img/happy-birthday-clojure/clojure.jpeg&#34; alt=&#34;Clojure logo&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
&lt;/figure&gt;



&lt;hr /&gt;

&lt;p&gt;This year is the tenth birthday of the release of &lt;a href=&#34;http://blog.cognitect.com/blog/2017/8/18/come-celebrate-seven-years-of-conj-10-years-of-clojure&#34;&gt;Clojure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Although Clojure is gaining momentum and the community is growing at a steady
pace worldwide, after ten years the number of places where active communities
have formed is small and Clojure enthusiasts are still struggling to use their
favorite language professionally.&lt;/p&gt;

&lt;p&gt;In Europe for instance (which is my point of view), I can see strong
communities have formed in northern Europe, in London for example, Finland,
Netherlands or Germany, with conference taking place every year and companies
supporting them and the Clojure job market.&lt;/p&gt;

&lt;p&gt;In France however, the number of &amp;ldquo;Clojurians&amp;rdquo; is pretty small. There is a
Clojure User Group in Paris with really active people, which is great. Other
than that I don&amp;rsquo;t hear a whole lot about Clojure around here.&lt;/p&gt;

&lt;p&gt;Earlier this year I was listening to &lt;a href=&#34;https://twitter.com/mohitthatte&#34;&gt;Mohit Thatte&lt;/a&gt;&amp;rsquo;s conversation
in &lt;a href=&#34;https://www.functionalgeekery.com/episode-82-mohit-thatte/&#34;&gt;this episode of Functional Geekery&lt;/a&gt;.
He has created a &lt;a href=&#34;http://inclojure.org&#34;&gt;Clojure conference in India&lt;/a&gt;, from scratch (!),
in order to spread the word about Clojure and:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;nurture the small but growing community of Clojure programmers in India&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This inspired me a lot and the fact that I couldn&amp;rsquo;t attend the seventh &lt;em&gt;conj&lt;/em&gt;,
for Clojure&amp;rsquo;s tenth birthday, added on top of all the frustration generated
by having to use other technologies and programming models all day long made
me decide to take actions.&lt;/p&gt;

&lt;p&gt;I have made a proposal to talk about Lisp and Clojure at our local (Toulouse)
Java User Group. The talk got accepted and I tried (more on this in a next
article) to express the fundamentals of Lisp, Clojure and the way we treat
information in our systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This talk was also a perfect tribune to announce the creation of the
&lt;a href=&#34;https://www.meetup.com/fr-FR/Toulouse-Clojure-User-Group/&#34;&gt;Toulouse Clojure User Group&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In 2013 when I was forced by &lt;a href=&#34;https://twitter.com/FrancoisRoyer&#34;&gt;this guy&lt;/a&gt;
(he was my boss) to adopt a Lisp, it felt like my brain was melting.&lt;br /&gt;
Now I&amp;rsquo;m frustrated almost every day I have to use anything else (which is part
of why I don&amp;rsquo;t do frontend development anymore, all the other tech stacks in
this field feel hostile and &lt;em&gt;complected&lt;/em&gt; in every possible way).&lt;/p&gt;

&lt;p&gt;My goal with this user group is more or less the same as any user group
creator: to spread the word about a subject I am really excited about and
nurture the community that will form around it.&lt;/p&gt;

&lt;p&gt;I also want it to be a place where programmers can come and talk about other
functional programming languages: Haskell, Scala, Elixir, Erlang, Idris,
PureScript, Elm, Kotlin, Agda, Coq, etc.&lt;br /&gt;
There is no &amp;ldquo;functional meetup&amp;rdquo; around here and I think we could all benefit
from cross pollination and sharing ideas, just expect me to be advocating for
Clojure a little bit more.&lt;/p&gt;

&lt;p&gt;Local user groups are local by definition, so I don&amp;rsquo;t expect people coming
to work in the area from more than 20 to 40km to attend an afterwork meetup.&lt;br /&gt;
But if you are in the area, and are interested in Clojure or in functional
programming, &lt;a href=&#34;https://twitter.com/ClojureToulouse&#34;&gt;let&amp;rsquo;s meet&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Just use Clojure already!</title>
      <link>http://i-rant.arnaudbos.com/use-clojure-already/</link>
      <pubDate>Fri, 10 Nov 2017 13:41:21 +0100</pubDate>
      
      <guid>http://i-rant.arnaudbos.com/use-clojure-already/</guid>
      <description>
&lt;figure  &gt;
    
        &lt;img src=&#34;http://i-rant.arnaudbos.com/img/use-clojure-already/lisp_cycles.png&#34; alt=&#34;xkcd joke&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h6&gt;&lt;em&gt;Lisp as a secret weapon&lt;/em&gt;&lt;/h6&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;hr /&gt;

&lt;p&gt;I hear a lot of talking going on about &lt;a href=&#34;https://kotlinlang.org/&#34;&gt;Kotlin&lt;/a&gt; around me lately.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no doubt that since Kotlin v1.0 has been released last year, a lot
has happened around it from the Google announcement that
Kotlin would benefit from
&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/&#34;&gt;first class support on Android&lt;/a&gt;, up to the
hiring of &lt;a href=&#34;https://twitter.com/JakeWharton&#34;&gt;Jake Wharton&lt;/a&gt; (a figure in the world of Android
developers).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve never been very enthusiastic about Kotlin, but my colleagues at
&lt;a href=&#34;http://www.monkeypatch.io/&#34;&gt;MonkeyPatch&lt;/a&gt; seem to be following the hype (muahaha&amp;hellip;) and are
becoming more and more addicted to it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/ilaborie&#34;&gt;Igor&lt;/a&gt; offered to make a live demo in order to show me what it is they
(he) like about Kotlin.&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;fr&#34; dir=&#34;ltr&#34;&gt;On profite de l&amp;#39;été pour se faire des petites sessions de BBL &lt;a href=&#34;https://twitter.com/hashtag/dev?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dev&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/passion?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#passion&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/summer?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#summer&lt;/a&gt; &lt;a href=&#34;https://t.co/54JG68txhs&#34;&gt;pic.twitter.com/54JG68txhs&lt;/a&gt;&lt;/p&gt;&amp;mdash; MonkeyPatch (@MonkeyPatch_io) &lt;a href=&#34;https://twitter.com/MonkeyPatch_io/status/893066399794556928?ref_src=twsrc%5Etfw&#34;&gt;August 3, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;p&gt;During his presentation I&amp;rsquo;ve noticed a few points that I disliked, but before
jumping to conclusion I decided to dig a bit further, reading
&lt;a href=&#34;https://www.manning.com/books/kotlin-in-action&#34;&gt;Kotlin in Action&lt;/a&gt; during vacations two weeks later.&lt;/p&gt;

&lt;p&gt;I also asked on our private Slack team:
&lt;strong&gt;&lt;em&gt;&amp;ldquo;What is Kotlin&amp;rsquo;s value proposition?&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Amongst other small things, the consensus begun to build: &lt;em&gt;&amp;ldquo;It&amp;rsquo;s a better
Java than Java&amp;rdquo;&lt;/em&gt;&amp;hellip;&lt;br /&gt;
Exactly what I feared.&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Finished. Nice book, &lt;a href=&#34;https://twitter.com/hashtag/Kotlin?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Kotlin&lt;/a&gt; is a better Java than &lt;a href=&#34;https://twitter.com/hashtag/Java?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Java&lt;/a&gt; and increases productivity. But I still prefer &lt;a href=&#34;https://twitter.com/hashtag/Clojure?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Clojure&lt;/a&gt;. I&amp;#39;ll write about that soon &lt;a href=&#34;https://t.co/4ZgHScppAA&#34;&gt;pic.twitter.com/4ZgHScppAA&lt;/a&gt;&lt;/p&gt;&amp;mdash; Arnaud Bos (@arnaud_bos) &lt;a href=&#34;https://twitter.com/arnaud_bos/status/898808015146627072?ref_src=twsrc%5Etfw&#34;&gt;August 19, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;p&gt;To fulfill the promise made in this tweet, I took it as a game to code the
same code example Igor showed me in &lt;a href=&#34;https://clojure.org/&#34;&gt;Clojure&lt;/a&gt; in order to return
the favor to my colleagues.&lt;/p&gt;

&lt;p&gt;And I&amp;rsquo;ve decided to start a series of blog posts about Clojure&amp;rsquo;s features and
Kotlin&amp;rsquo;s features in order to express why &lt;strong&gt;&lt;em&gt;I&lt;/em&gt;&lt;/strong&gt; don&amp;rsquo;t see the later being that
much of an improvement, despite its growth in popularity.&lt;/p&gt;

&lt;p&gt;But using Clojure is not like riding on unicorns all day long either.&lt;br /&gt;
Although I fail to see if some other new languages solve real problems or just
add more puzzles to solve to our daily share or incidental complexity, I will
address some pain points I&amp;rsquo;ve encountered too in Clojure.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This post was actually in draft form since September 15th (I screwed up my
publication planning) and in the mean time I&amp;rsquo;ve had many occasions to express
my &lt;em&gt;&amp;ldquo;obsessive enthusiasm&amp;rdquo;&lt;/em&gt; of Clojure.&lt;/p&gt;

&lt;p&gt;And the static typing and type systems aficionados around me (who seem to be
legion, interestingly) have come to discover and appreciate &lt;a href=&#34;https://www.idris-lang.org/&#34;&gt;Idris&lt;/a&gt; and
its &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependent_type&#34;&gt;dependent types&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Well... I&amp;#39;d like to know fundamentally why... And anyway have you ever tried &lt;a href=&#34;https://twitter.com/idrislang?ref_src=twsrc%5Etfw&#34;&gt;@idrislang&lt;/a&gt; ?&lt;/p&gt;&amp;mdash; Frédéric Cabestre (@fcabestre) &lt;a href=&#34;https://twitter.com/fcabestre/status/912183360285544448?ref_src=twsrc%5Etfw&#34;&gt;September 25, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;p&gt;I remember having heard about Idris around summer 2016 in this
&lt;a href=&#34;https://www.functionalgeekery.com/episode-54-edwin-brady/&#34;&gt;podcast&lt;/a&gt;.&lt;br /&gt;
I even added the episode to my favorites: which means I wanted to get back to
it and listen again later.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s nice to have people around ready to talk about these stuff.&lt;br /&gt;
This tweet made me realize it would be a good way to also inject a bit of
Idris dependent types and interactive editing features in the mix and see how
Clojure compares on the matter (Kotlin being out of the equation here).&lt;/p&gt;

&lt;p&gt;I hope this post will be the first of a series where &lt;a href=&#34;https://twitter.com/ilaborie&#34;&gt;Igor&lt;/a&gt; and I (and
maybe &lt;a href=&#34;https://twitter.com/fcabestre&#34;&gt;Frederic&lt;/a&gt; on Idris?) might go back and forth, answering
each other. It&amp;rsquo;s up to them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Klipse</title>
      <link>http://i-rant.arnaudbos.com/test-klipse/</link>
      <pubDate>Mon, 23 Jan 2017 13:23:08 +0100</pubDate>
      
      <guid>http://i-rant.arnaudbos.com/test-klipse/</guid>
      <description>&lt;p&gt;Foo&lt;/p&gt;

&lt;div class=&#34;language-klipse&#34;
  
  &gt;
  

Bar

&lt;/div&gt;

</description>
    </item>
    
  </channel>
</rss>