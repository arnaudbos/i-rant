<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
        
    <meta property="og:title" content="Water Pouring Problem in Clojure" />
    <meta property="og:description" content="Solving the water pouring problem in Clojure and detailing my approach at the REPL" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://i-rant.arnaudbos.com/water-pouring-in-clojure/" />
    
    <meta property="og:image" content="https://i-rant.arnaudbos.com/img/water-pouring-in-clojure/die-hard-3-water-puzzle.jpg" />
    

    <meta name="description" content="My corner of teh interweb.">
    <link rel="shortcut icon" type="image/x-icon" href="https://i-rant.arnaudbos.com/img/favicon.ico">
    <title>Water Pouring Problem in Clojure</title>
    <meta name="generator" content="Hugo 0.54.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Raleway|Fira+Code&display=swap">
    <link rel="stylesheet" type="text/css" href="https://i-rant.arnaudbos.com/css/main.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/darcula.min.css">
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://www.arnaudbos.com/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="https://i-rant.arnaudbos.com/">BLOG</a></li>
        
        <li><a href="https://side-effects.arnaudbos.com/">PROJECTS</a></li>
        
        <li><a href="https://talks.arnaudbos.com/">TALKS</a></li>
        
        <li><a href="https://level-up.arnaudbos.com/">LEVEL-UP</a></li>
        
        <li><a href="https://vitae.arnaudbos.com/">RESUME</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      <div class="container">
        <div class="blog-post">
          <h3>
            <a href="/water-pouring-in-clojure/">Water Pouring Problem in Clojure</a>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
          November 28, 2017
          &nbsp;&nbsp;
          —
          &nbsp;&nbsp;
          19 minutes read
          </h4>
        </div>
        <div>
          <h4>
            
            <span class="label label-success">clojure</span>
            
            <span class="label label-success">REPL</span>
            
            <span class="label label-success">kotlin</span>
            
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              
<figure  >
    
        <img src="/img/water-pouring-in-clojure/die-hard-3-water-puzzle.jpg" alt="Caption of the water puzzle scene in Die Hard with a Vengeance"
            width="100%"
            />
    
    
    <figcaption>
        <h6><em>Die Hard with a Vengeance — Water puzzle scene</em></h6>
        
    </figcaption>
    
</figure>



<hr />

<p>This post is the first or a series where I explore Clojure features
and start a discussion with my colleague <a href="https://twitter.com/ilaborie">Igor</a> about <a href="https://clojure.org/">Clojure</a>
and <a href="https://kotlinlang.org/">Kotlin</a>.</p>

<p>This summer, <a href="https://twitter.com/ilaborie">Igor</a> offered to make a live Kotlin demo of a nice problem
he&rsquo;s been <a href="https://github.com/ilaborie/kotlin-pouring">working on</a> that can serve as a fine exercise to
discover and experiment a programming language: the
<a href="https://en.wikipedia.org/wiki/Water_pouring_puzzle">Water pouring puzzle</a>.</p>

<p>In this article I talk about the <strong><em>programming style</em></strong> I&rsquo;ve
used to find my solution: a data oriented, bottom-up approach, at the
REPL.</p>

<hr />

<p>Igor&rsquo;s <a href="https://github.com/ilaborie/kotlin-pouring#guideline-try-to-implements-with-immutable-data-structure">guideline</a> offers a good starting point
on how OO and/or static typing (including myself when I switch to Java for
instance) would solve this problem: model the world.<br />
Notice how, by following this recipe, you don&rsquo;t get to handle or transform
any data until point 15 of about 30.</p>

<p>Although I understand how this is more usual, familiar and maybe the most
straightforward way to do things for a majority of developers, to me this is a
major drawback. It means that half of the time you are spending laying out
things, hoping the Lego blocks will fall into place, thinking about types and
safety when all you should be thinking about should be (IMO) how do I solve
this particular problem.</p>

<p>After a few years of <a href="http://vvvvalvalval.github.io/posts/what-makes-a-good-repl.html">REPL</a> <a href="https://vimeo.com/223309989">driven development</a> I
know that I have a good tool to functionally, expressively and
incrementally solve a problem.</p>

<p>This post is basically a transcript of my thought process as I was writing
a solver to the Water pouring puzzle at the REPL.<br />
It was interesting to take the time to reflect and watch myself work as
I was proceeding, it took more time but it was definitely an interesting
experiment.</p>

<hr />

<p>I setup the boilerplate first. (leiningen, dependencies, etc) and a
namespace to work in:</p>

<div class="language-klipse"
  
  >
  
(ns clojure-pouring.repl)

</div>


<p>At the REPL, the fundamental principle is: <strong><em>exploratory programming</em></strong>.<br />
I don&rsquo;t know how to find the solution to this problem (yet!),
all I have at this point is a namespace.</p>

<p>I must begin somewhere, so let&rsquo;s start with some data: a glass has a total
capacity and a current state (<code>0</code> by default), I need a collection of those.</p>

<p>I start at the REPL by declaring <code>inital-state</code>:</p>

<div class="language-klipse"
  
  >
  
(def initial-state
  [{:capacity 5
    :current 0}
   {:capacity 3
    :current 0}
   ])

initial-state

</div>


<p>Then <code>final-state</code> to illustrate the target:</p>

<div class="language-klipse"
  
  >
  
(def final-state
  [{:capacity 5
    :current 4}
   {:capacity 3
    :current 0}
   ])

final-state

</div>


<p>Pretty easy: each glass is a <code>map</code> and I put two of those in a <code>vector</code>.<br />
Just thinking about the amount of code I would have to write in Java or Kotlin
just to get a short sample of data like this gives me goosebumps.</p>

<p>Kotlin <a href="https://discuss.kotlinlang.org/t/plans-for-collection-literals/2049">might</a>,
at <a href="https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/">some point</a>,
have collection literals similar to those, or not.<br />
There seems to be a debate inside the community whether this is a desired
feature or not, despite the clear winner of the community survey.</p>

<p>Communicating intent is an important part of a language and Kotlin&rsquo;s debate
around collection literals seems to fall in the category of convenient syntax
vs intent. Why?<br />
Because Kotlin&rsquo;s designers have made the choice to support both mutable and
immutable collections as first class citizens. So how do you define what <code>{}</code>
is or <code>[]</code> is? Is it mutable or immutable?<br />
The debate also seem to include considerations such as ordered/unordered and the
choice of syntax between lists and sets. Good luck figuring that out.</p>

<p>Clojure is based on first-class persistent data-structures so mutation is not
and option, and its collection literals are easily identified:</p>

<ul>
<li><code>()</code> for lists (PersistentList)</li>
<li><code>[]</code> for vectors (PersistentVector)</li>
<li><code>{}</code> for a maps (PersistentHashMap)</li>
<li><code>#{}</code> for sets (PersistentHashSet)</li>
</ul>

<p>Want ordered/unordered variants? array-maps? queues? Sure, just use the
appropriate constructor, the collections you will use the most are available
as literals and it&rsquo;s a burden not put on you, the developer.<br />
View it as <em>&ldquo;only convenient&rdquo;</em> if you want to ditch the argument and discussion
altogether, but with mutation out of the way a whole class of problems are gone
once again, and the benefit of being able to just copy and paste
around printed representations of data-structures (in REPL or in logs) and
use them verbatim as code is priceless.</p>

<p>Alright, so the actions allowed to be performed on a glass are either to <em>pour</em>
some quantity out of it, or to <em>fill</em> it with some quantity.</p>

<p>So I implement a <code>pour</code> function first:</p>

<div class="language-klipse"
  
  >
  
(defn pour
  ([glass]
   (assoc glass :current 0))
  ([glass quantity]
   (let [{:keys [current]} glass]
     (assoc glass :current (- current
                              (min current quantity))))))

</div>


<p>This is a multi-arity function:</p>

<ul>
<li>The first implementation takes a glass as its only parameter and returns a
<a name="anew"></a>new<sup><a href="#new">1</a></sup> empty glass of the same capacity.</li>
<li>The second implementation takes a glass as its first parameter and a quantity
as its second parameter and returns a new glass <em>poured out of</em> the given
quantity or <em>poured out empty</em> if it contains less than the given quantity.</li>
<li>In the second arity, I <em>destructure</em> the first parameter (the glass) which
is a map, in order to get its <code>current</code> key only, as I don&rsquo;t care about its
<code>capacity</code>.</li>
<li><code>assoc</code> is (<a href="https://clojuredocs.org/clojure.core/assoc">for short</a>)
a standard library function that returns a new map containing the new
<code>key/value</code> mapping.</li>
</ul>

<p>Don&rsquo;t worry about the prefix notation, it&rsquo;s not difficult, it&rsquo;s just different,
you&rsquo;re not
<em><a href="https://www.infoq.com/presentations/Simple-Made-Easy">familiar</a></em> with it, and
you&rsquo;ll get used to it.</p>

<p>Test <code>pour</code>:</p>

<div class="language-klipse"
  
  >
  
(println (pour {:capacity 5 :current 4}))
(println (pour {:capacity 8 :current 4} 2))
(println (pour {:capacity 8 :current 4} 5))

</div>


<ul>
<li>Pouring out empty a glass of capacity <code>5</code> returns an empty glass of capacity
<code>5</code>.</li>
<li>Pouring out <code>2</code> from a glass of capacity <code>8</code> containing <code>4</code> returns
a glass of capacity <code>8</code> containing <code>2</code>.</li>
<li>And pouring out <code>5</code> from a glass of capacity <code>8</code> containing <code>4</code> just returns
and empty glass, not <code>-1</code>.</li>
</ul>

<p>Ignore the last <code>nil</code> in the results, it&rsquo;s just the live code evaluation
plugin that prints it out as the result of the last <code>println</code> call.<br />
Go ahead and play with it a little, even change the implementation above
if you will.</p>

<p>Now the <code>fill</code> function:</p>

<div class="language-klipse"
  
  >
  
(defn fill
  ([glass]
   (assoc glass :current (:capacity glass)))
  ([glass quantity]
   (let [{:keys [capacity current]} glass]
     (assoc glass :current (+ current
                              (min (- capacity current) quantity))))))

</div>


<p>This is also a multi-arity function:</p>

<ul>
<li>The first implementation fills a glass up to its maximum capacity.</li>
<li>The second implementation fills a glass <em>up to</em> its maximum capacity given
a quantity to fill it with.</li>
<li>Both return a new glass of course (not a copy!!!), we&rsquo;re in <strong><em>immutable</em></strong>
land here.</li>
</ul>

<p>Test <code>fill</code>:</p>

<div class="language-klipse"
  
  >
  
(println (fill {:capacity 5 :current 0}))
(println (fill {:capacity 8 :current 4} 1))
(println (fill {:capacity 8 :current 7} 2))

</div>


<ul>
<li>Filling an empty glass returns a glass full.</li>
<li>Filling <code>1</code> into a glass of capacity <code>8</code> that already contains <code>4</code> returns a
glass of capacity <code>8</code> containing <code>5</code>.</li>
<li>And filling <code>2</code> into a glass of capacity <code>8</code> that already contains <code>7</code> returns
a glass of capacity <code>8</code> that is full, not <code>9</code>.</li>
</ul>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/water-pouring-in-clojure/jug2.jpg" itemprop="contentUrl" data-size="728x485">
      <img src="/img/water-pouring-in-clojure/jug2.jpg" itemprop="thumbnail"
        
        
        width="390px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/water-pouring-in-clojure/jug3.jpg" itemprop="contentUrl" data-size="728x485">
      <img src="/img/water-pouring-in-clojure/jug3.jpg" itemprop="thumbnail"
        
        
        width="390px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>



</div>


<p>Let&rsquo;s take a break here.</p>

<hr />

<p>One of the major benefits of a good REPL (and Clojure&rsquo;s REPL is a good one),
is the ability to explore: write one function at a time, execute it
<strong>right away</strong> with a small amount of data, creating a really short
<strong>feedback loop</strong> in order to <strong>explore</strong> multiple solutions.</p>

<p>In this blog post I use <a href="https://github.com/viebel/klipse">Klipse</a> in order to present my iterative
process and <strong>let you play with the code</strong>.<br />
This is nice for you to get a feel and try different inputs to my functions,
or write different implementations if you want to.</p>

<p>A good REPL is superior to TDD because it lets you write (or better: keep)
tests that matter, get the result out of a function call and use it again as
data that can populate your <em>real</em> tests.</p>

<p>But if you&rsquo;ve tried other REPLs (ruby, python, node, etc.), you may be
thinking that a REPL is not practical, because it forces you to copy/paste
code all the time, go back and forth in you REPL&rsquo;s history in order to
retrieve past results and implementations just to change a few characters.</p>

<p>And this is where tooling is important.</p>

<p>Lots of Clojure developers use emacs (or cursive, an Intellij plugin) and
benefit from its integration with the REPL.<br />
I, personnally, have been enjoying <a href="http://lighttable.com/">Light Table</a> since 2013, and
this is a screenshot of my laptop while I&rsquo;m working at the REPL:</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/water-pouring-in-clojure/screenshot.png" itemprop="contentUrl" data-size="1440x900">
      <img src="/img/water-pouring-in-clojure/screenshot.png" itemprop="thumbnail"
        
        title="Light Table instaREPL"
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Light Table instaREPL</div>
</div>


<p>Do you see the &ldquo;blue&rdquo; data? This is the result of evaluating a Clojure
expression in the editor itself.<br />
This alone has made it difficult for me to switch to another editor ever since.</p>

<p>At the REPL, I type in <strong>data</strong>, I pass it to <strong>functions</strong> and I get the
<strong>result</strong> (which I use later as new input/expected output for other tests)
in front of my eyes.<br />
I define <strong>new functions</strong> and make extensive use of <em>&ldquo;variable shadowing&rdquo;</em> to
<strong>modify the implementation of existing functions</strong>.</p>

<p>No classes, no types, no FactoryFactoryAbstractDelegateProxyPattern:
just data and functions&hellip;<br />
I can hear you, static typing addict: <strong>BUT IT IS NOT SAFE!</strong><br />
Yes, I know, I just don&rsquo;t care at this point! I told you, I&rsquo;m <strong>exploring</strong>.
I want to go fast, iterate quickly, not model the whole universe and bang my
head against the type checker.</p>

<p>I can just rely on my tests for now and use simple assertions or
<a href="https://clojure.org/about/spec">specifications</a> later (or now, but right now
I&rsquo;m not, obviously) to refine.</p>

<p>I&rsquo;ve never had a shortest feedback loop in any other language I&rsquo;ve used, this is
pure gold.</p>

<hr />

<p>Let&rsquo;s continue our problem solving.</p>

<p>I have a pouring and a filling function.<br />
Now I&rsquo;d need a function that takes a collection of glasses (state),
apply an action (commonly called a &lsquo;move&rsquo; in the current domain language)
and return a new, updated collection of glasses (new state).</p>

<p>What characterizes a move? It&rsquo;s either an <code>empty</code>, <code>pour</code> or <code>fill</code> action
associated with glass indices:</p>

<ul>
<li>empty <code>from</code> the nth glass</li>
<li>fill <code>to</code> the nth glass</li>
<li>pour <code>from</code> the mth glass <code>to</code> the nth glass</li>
</ul>

<p>Expressivity matters, so maybe a move would be best represented by a map.<br />
A map with a type that characterizes the move (<code>empty</code>, <code>fill</code>, <code>pour</code>) and
subjects that indicate the source / target / both of the move (<code>from</code>, <code>to</code>):</p>

<div class="language-klipse"
  
  >
  
(println "Empty glass 0:" {:type :empty :from 0})
(println "Fill glass 1:" {:type :fill :to 1})
(println "Pour glass 1 into glass 0:" {:type :pour :from 1 :to 0})

</div>


<p>I&rsquo;m beginning to think that a bit of <em>Ad-hoc polymorphism</em> would
be great in order to dispatch on the type of move: let&rsquo;s use
<em>multimethods</em>.</p>

<div class="language-klipse"
  
  >
  
(defmulti ->move
  "Apply a move to the given state and return the new state."
  (fn [state move] (:type move)))

</div>


<p>The <code>defmulti</code> macro defines a new multimethod with the associated
<code>dispatch function</code>.<br />
Which means that the <code>-&gt;move</code> function will take two parameters, and the
dispatch function will <em>choose</em> the appropriate implementation.</p>

<p>In this case I dispatch based on the value associated to the <code>:type</code> key in the
<code>move</code> parameter.<br />
A <code>:empty</code> move will dispatch to the <code>-&gt;move :empty</code> multimethod.<br />
A <code>:fill</code> move will dispatch to the <code>-&gt;move :fill</code> multimethod.<br />
A <code>:pour</code> move will dispatch to the <code>-&gt;move :pour</code> multimethod.</p>

<div class="language-klipse"
  
  >
  
; Empty the glass at index from
(defmethod ->move :empty
  [state {:keys [from]}]
  (update-in state [from] pour))

; Fill the glass at index to
(defmethod ->move :fill
  [state {:keys [to]}]
  (update-in state [to] fill))

; Pour the glass at index from into the glass at index to
(defmethod ->move :pour
  [state {:keys [from to]}]
  (let [quantity (min (get-in state [from :current])
                      (- (get-in state [to :capacity])
                         (get-in state [to :current])))]
    (-> state
        (update-in [from] pour quantity)
        (update-in [to] fill quantity))))

</div>


<p><code>update-in</code> is a <a href="https://clojuredocs.org/clojure.core/update-in">standard library</a>
function that takes a data structure as a first parameter and &ldquo;updates&rdquo;
(immutable, remember?) the value nested at the path given by the second
parameter by applying to it the function supplied as the third parameter&hellip;<br />
Don&rsquo;t pretend you didn&rsquo;t understand, just reread carefully.</p>

<p>Let&rsquo;s take our <code>-&gt;move :empty</code> multimethod as an example.<br />
Since our move is an <code>:empty</code>, we destructure this parameter to get the
value at the <code>:from</code> key: the index of the glass in <code>state</code> that we want to
empty.<br />
Once the glass has been fetched, <code>update-in</code> will evaluate the <code>pour</code> function
with the glass as its sole parameter.<br />
Since I&rsquo;ve implemented the 1-arity of the <code>pour</code> function so that it just
returns a new empty glass of same capacity, this result will <em>replace</em>
the glass in the <code>state</code>.</p>

<p>Let&rsquo;s test <code>-&gt;move</code> to &ldquo;manually&rdquo; go from <code>initial-state</code> to <code>final-state</code>:</p>

<div class="language-klipse"
  
  >
  
(-> initial-state
    (->move {:type :fill :to 1})
    (->move {:type :pour :from 1 :to 0})
    (->move {:type :fill :to 1})
    (->move {:type :pour :from 1 :to 0})
    (->move {:type :empty :from 0})
    (->move {:type :pour :from 1 :to 0})
    (->move {:type :fill :to 1})
    (->move {:type :pour :from 1 :to 0})
    )

</div>


<p>It works!</p>

<p>I must now implement a function that, when given a collection of glasses,
returns a collection of possible moves that can be applied to this state in
order to produce a <em>meaningful</em> new collection of glasses.</p>

<p>Meaningful as in:</p>

<ul>
<li>not emptying an empty glass,</li>
<li>not filling a glass that is full, and</li>
<li>not pouring into &lsquo;itself&rsquo;, which gets us nowhere</li>
</ul>

<div class="language-klipse"
  
  >
  
(defn glasses->index
  "Filter the glasses by the filter-fn function and
  return the index the filtered item had in the
  glasses collection."
  [glasses filter-fn]
  (->> glasses
       (map-indexed #(vector %1 %2))
       (filter (fn [[idx value]] (filter-fn value)))
       (map first)))

</div>


<p>I&rsquo;m not going to explain everything, just look at the input and output in this
test of <code>glasses-&gt;index</code>:</p>

<div class="language-klipse"
  
  >
  
(println "Indices of non-empty glasses:"
         (glasses->index final-state (comp pos? :current)))
(println "Indices of glasses of capacity 3:"
         (glasses->index final-state (comp #(= 3 %) :capacity)))

</div>


<p>The <em>&ldquo;indexing&rdquo;</em> works, now the function for listing moves:</p>

<div class="language-klipse"
  
  >
  
(defn available-moves
  "Return the list of valid moves from current state of glasses."
  [glasses]
  (let [non-empty (glasses->index glasses (comp pos? :current))
        non-full (glasses->index glasses #(< (:current %) (:capacity %)))]
    (concat
      (map #(hash-map :type :empty :from %) non-empty)
      (map #(hash-map :type :fill  :to   %) non-full)
      ; I really like this one
      (for [from non-empty to non-full :when (not= from to)]
        {:type :pour :from from :to to}))))

</div>


<p>Concatenate the list of moves able to empty the non-empty glasses, fill the
non-full glasses and pour the non-empty glasses into the distinct non-full
glasses.</p>

<p>Test <code>available-moves</code>:</p>

<div class="language-klipse"
  
  >
  
(println (available-moves initial-state))
(println (available-moves final-state))

</div>


<p>I can get the list of moves that are practicable, now let&rsquo;s
explore the next glasses available from the current glasses.</p>

<div class="language-klipse"
  
  >
  
(defn explore
  [glasses moves]
  (map (partial ->move glasses) moves))

</div>


<p>Test <code>explore</code>:</p>

<div class="language-klipse"
  
  >
  
(explore initial-state (available-moves initial-state))

</div>


<p>Given a list of glasses (a state), returns the list of glasses I could get to
(next states) by applying the moves that are available from my current state.</p>

<a class="fold title" onclick="$('#explore').toggleClass('hidden');">[Exploration]</a>
<div id="explore" class="fold content hidden">
  <p>I won&rsquo;t need this function because in order to find the list of moves
leading from a state to another I must keep the previous moves in memory when
exploring further&hellip;</p>

<p><code>explore</code> is not enough, but at least I know how to explore the spectrum
of all the possible next states for a given state and list of moves.</p>

<p>See? I&rsquo;ve <em>explored</em>, I&rsquo;ve made an experiment with a function mapped over
some data. And it didn&rsquo;t cost much because my feedback loop is really short.</p>

<p>I&rsquo;ve realized this path is not going to help, so I can just discard it and
refine my understanding of the steps I need to take to reach my goal.</p>

</div>


<p>Given a <code>node</code> containing glasses and the sequence of moves leading to
them, return a list of successor nodes.</p>

<div class="language-klipse"
  
  >
  
(defn expand
  [{:keys [glasses moves] :as node}]
  (let [next-moves (available-moves glasses)]
    (map #(hash-map :glasses (->move glasses %)
                    :moves (conj moves %))
         next-moves)))

</div>


<p>I evaluate the moves available from the current node&rsquo;s glasses and for each
one of them I return a new node consisting of the next state of glasses and
the augmented list of move leading to it.</p>

<p>Test <code>expand</code>:</p>

<div class="language-klipse"
  
  >
  
(println
  (expand
    {:glasses [{:capacity 5 :current 5} {:capacity 3 :current 0}]
     :moves [{:type :fill :to 0}]}))

</div>


<p>Nice, given glasses and the <code>history</code> of moves that led from an initial
state to these glasses, I can get the list of next states that are
<em>possible</em>, with their respective history of moves.</p>

<p>But at some point I might reach a state that I have already visited in the
past&hellip; So it would be interesting to keep an index of the states that I
have already visited in order to query it and avoid useless computation.</p>

<p>Let&rsquo;s <em>&ldquo;backtract&rdquo;</em> the already visited nodes:</p>

<div class="language-klipse"
  
  >
  
(defn backtrack
  "Returns true if a node has been visited."
  [visited {:keys [glasses]}]
  (not (contains? visited glasses)))

</div>


<p>Test <code>backtrack</code>:</p>

<div class="language-klipse"
  
  >
  
(backtrack #{[{:capacity 5 :current 0} {:capacity 3 :current 0}]}
           {:glasses [{:capacity 5 :current 5} {:capacity 3 :current 0}]
            :moves [{:type :fill :to 0}]})

</div>


<p>The first parameter of <code>backtrack</code> is a set, so <code>contains?</code> is <code>O(1)</code>, not
<code>O(n)</code>.</p>

<p>I&rsquo;m almost there, right?<br />
But I must stop searching at some point, so let&rsquo;s identify a solution among
a set of candidates:</p>

<div class="language-klipse"
  
  >
  
(defn has-solution?
  [target successors]
  (some #(when (= target (:glasses %)) (:moves %))
        successors))

</div>


<p><code>some</code> is a <a href="https://clojuredocs.org/clojure.core/some">standard library</a>
function that returns the first logical true value of the predicate function
result.<br />
My predicate function returns the list of moves leading to the current node
when the glasses of the node match the target glasses state, so if the
<code>successors</code> collection contains the solution, the list of moves to get
there is returned.</p>

<p>Test <code>has-solution?</code>:</p>

<div class="language-klipse"
  
  >
  
(println "Does not have solution:"
  (has-solution?
    [{:capacity 5 :current 4} {:capacity 3 :current 0}]
    []))

(println "The solution (list of moves) is:"
  (has-solution?
    [{:capacity 5 :current 4} {:capacity 3 :current 0}]
    [{:glasses [{:capacity 5 :current 0}] :moves []}
     {:glasses [{:capacity 5 :current 4} {:capacity 3 :current 0}] :moves [:foo :bar]}]))

</div>


<p>And now the final part: I must compose the functions I have written so far
in order to implement a solver.</p>

<p>This is <em>bottom-up</em>. I know I have all the parts of my solver in place and
I have tested most of them along the way.</p>

<p>Let&rsquo;s loop over glasses nodes, keeping track of the already visited ones,
searching for a solution leading to the target state:</p>

<div class="language-klipse"
  
  >
  
(require '[clojure.set :as set])

(defn solver
  "Given a target state, returns a function that will solve the water pouring
  problem for an initial state"
  [target]
  (let [has-solution-fn? (partial has-solution? target)]
    (fn [glasses]
      ; Start with an empty set of visited states and an empty list of moves
      (loop [visited #{} nodes [{:glasses glasses :moves []}]]
        (if-let [solution (has-solution-fn? nodes)]
          solution
          (let [successors (mapcat #(expand %) nodes)
                valid-successors (filter (partial backtrack visited) successors)
                newly-visited (into #{} (map :glasses valid-successors))]
            (recur (clojure.set/union visited newly-visited)
                   valid-successors)))))))

</div>


<p>Test <code>solver</code>:</p>

<div class="language-klipse"
  
  >
  
(def simple-solver
  (solver [{:capacity 5 :current 4}
           {:capacity 3 :current 0}]))

(simple-solver [{:capacity 5 :current 0}
                {:capacity 3 :current 0}])

</div>


<p>Test it again with a (seemingly) more complicated use case:</p>

<div class="language-klipse"
  
  >
  
(def less-simple-solver
  (solver [{:capacity 8 :current 4}
           {:capacity 5 :current 0}
           {:capacity 3 :current 0}]))

(less-simple-solver [{:capacity 8 :current 0}
                     {:capacity 5 :current 0}
                     {:capacity 3 :current 0}])

</div>


<hr />

<p>Functionally I could stop here because the problem is solved. But there are
some points that bother me, some <code>vars</code> names that don&rsquo;t reflect what
piece of information they carry or some functions that could be broken into
smaller ones.</p>

<p>Let&rsquo;s refactor a little:</p>

<p>Refactor <code>-&gt;move</code> to better reflect domain:</p>

<div class="language-klipse"
  
  >
  
(defmulti ->move
  "Apply a move to the given state and return the new state."
  (fn [glasses move] (:type move)))

(defmethod ->move :empty
  [glasses {:keys [from]}]
  (update-in glasses [from] pour))

(defmethod ->move :fill
  [glasses {:keys [to]}]
  (update-in glasses [to] fill))

(defmethod ->move :pour
  [glasses {:keys [from to]}]
  (let [quantity (min (get-in glasses [from :current])
                      (- (get-in glasses [to :capacity])
                         (get-in glasses [to :current])))]
    (-> glasses
        (update-in [from] pour quantity)
        (update-in [to] fill quantity))))

</div>


<p>Refactor <code>expand</code> by extracting the node builder:</p>

<div class="language-klipse"
  
  >
  
(defn make-node
  [glasses moves]
  {:glasses glasses
   :moves moves})

(defn expand-node
  [{:keys [glasses moves]}]
  (let [next-moves (available-moves glasses)]
    (->> next-moves
         (map #(make-node (->move glasses %) (conj moves %))))))

</div>


<p>Refactor <code>solver</code> by decomposing functions:</p>

<p>Let&rsquo;s create a <code>make-glass</code> utility function:</p>

<div class="language-klipse"
  
  >
  
(defn make-glass
  ([capacity]
   (make-glass capacity 0))
  ([capacity current]
   {:capacity capacity :current current}))

</div>


<p>Test <code>make-glass</code>:</p>

<div class="language-klipse"
  
  >
  
(make-glass 5)

</div>


<div class="language-klipse"
  
  >
  
(make-glass 8 3)

</div>


<p>Now a <code>initialize</code> function to create a vector of glasses from capacities or
capacities + quantities:</p>

<div class="language-klipse"
  
  >
  
(defn initialize
  ([capacities]
   (vec (map make-glass capacities)))
  ([capacities quantities]
   (vec (map make-glass capacities quantities))))

</div>


<p>Test <code>initialize</code>:</p>

<div class="language-klipse"
  
  >
  
(initialize [8 5 3])

</div>


<div class="language-klipse"
  
  >
  
(initialize [8 5 3] [4 0 0])

</div>


<p>Let&rsquo;s extract the part of the solver that find the successors of a collection
of nodes into <code>find-successors</code>:</p>

<div class="language-klipse"
  
  >
  
(defn find-successors
  [nodes]
  (mapcat #(expand-node %) nodes))

</div>


<p>Test <code>find-successors</code>:</p>

<div class="language-klipse"
  
  >
  
(find-successors [{:glasses [{:capacity 5 :current 0} {:capacity 3 :current 0}] :moves []}])

</div>


<p>Let&rsquo;s extract the part of the solver that filters out the successors that have
already been visited into <code>filter-successors</code>:</p>

<div class="language-klipse"
  
  >
  
(defn filter-successors
  [successors visited]
  (filter (partial backtrack visited) successors))

</div>


<p>Test <code>filter-successors</code>:</p>

<div class="language-klipse"
  
  >
  
(filter-successors
  [{:moves [{:type :fill :to 0}] :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}
   {:moves [{:type :fill, :to 1}], :glasses [{:capacity 5, :current 0} {:capacity 3, :current 3}]}]
  #{[{:capacity 5, :current 5} {:capacity 3, :current 0}]})

</div>


<p>We&rsquo;re almost done. Let&rsquo;s create a function to only keep a distinct set of
successors from a collection of candidates with <code>get-unique-glasses</code>.</p>

<div class="language-klipse"
  
  >
  
(defn distinct-glasses
  [successors]
  (into #{} (map :glasses successors)))

</div>


<p>Test <code>distinct-glasses</code>:</p>

<div class="language-klipse"
  
  >
  
(distinct-glasses
  [{:moves [{:type :fill :to 0}] :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}
   {:moves [{:type :fill, :to 1}], :glasses [{:capacity 5, :current 5} {:capacity 3, :current 0}]}])

</div>


<p>And now we can rewrite <code>solver</code> with these new pieces.</p>

<div class="language-klipse"
  
  >
  
(defn solver
  [capacities quantities]
  (let [initial (initialize capacities)
        target (initialize capacities quantities)
        has-solution-fn? (partial has-solution? target)]
    (fn []
      (let [first-node (make-node initial [])]
        (loop [visited #{initial} nodes [first-node]]
          (if-let [solution (has-solution-fn? nodes)]
            solution
            (let [successors (find-successors nodes)
                  valid-successors (filter-successors successors visited)
                  unique-glasses (distinct-glasses valid-successors)]
              (recur (clojure.set/union visited unique-glasses)
                     valid-successors))))))))

</div>


<p>Test <code>solver</code>:</p>

<div class="language-klipse"
  
  >
  
(def simple-solver (solver [5 3] [4 0]))
(println (simple-solver))

</div>


<div class="language-klipse"
  
  >
  
(def less-simple-solver (solver [8 5 3] [4 0 0]))
(println (less-simple-solver))

</div>


<p>Implement <code>-main</code>:</p>

<div class="language-klipse"
  
  >
  
(defn -main
  [& args]
  (assert (even? (count args)))
  (let [input (map #(Integer. (re-find  #"\d+" %)) args)
        solver-fn (apply solver (split-at (/ (count input) 2) input))]
    (println (solver-fn))))

</div>


<hr />

<p>It&rsquo;s been a pretty long article in the end. Together we&rsquo;ve implemented a
function to solve the water pouring problem for an arbitrary list of glasses
of some quantity in Clojure.</p>

<p>You can find the file I&rsquo;ve used to write this exploratory work
<a href="https://github.com/arnaudbos/clj-water-pouring/blob/master/src/clj_water_pouring/repl.clj">here</a>, and the final version of the solver without
all the evaluations <a href="https://github.com/arnaudbos/clj-water-pouring/blob/master/src/clj_water_pouring/core.clj">here</a>.</p>

<p>The thing that is the most interesting to me here is not the number of lines,
the safety or the provability of correctness.<br />
What I want to stress out is the development at the REPL.</p>

<p>You can see in the repository that I didn&rsquo;t even bother to write tests, because
I don&rsquo;t plan to share this work, publish it or maintain it. Nonetheless it has
been tested.<br />
I has been tested all the way from the beginning, at each function definition,
with data. You see, I didn&rsquo;t need to use TDD, and I didn&rsquo;t have to write some
temporary <code>main</code> function to pass inputs to the command line, and I didn&rsquo;t need
to wait until I&rsquo;ve assembled all the code together to try it fingers crossed.</p>

<p>Through the use of immutability, pure functions and first-class data literals
I feel like I can achieve more and iterate more quickly than with any other
language I&rsquo;ve used.<br />
I also argue that the Lisp syntax, although different, is an asset, because
there&rsquo;s no cognitive load associated with it: no magical keywords, no mix of
parents, braces or brackets for structure: just lists as functions and data.</p>

<p>Footnote:</p>

<p><a name="new">1</a>: This it is not exactly a new glass as in &lsquo;a copy&rsquo; but a
new pointer to a persistent data structure, a concept also know as
<em>structural sharing</em> (<a href="#anew">go back</a>)</p>

              <hr>
              <p>This blog uses <a target="_blank" href="https://web.hypothes.is/">Hypothesis</a> for public and private (group) comments.</p>
              <p>You can <em>annotate</em> or <em>highlight</em> words or paragraphs directly by selecting the text!</p>
              <p>If you want to leave a general comment or read what others have to say, please use the collapsible panel on the right of this page.</p>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 20, 2017
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/feedback-on-giving-a-talk/">Feedback on giving a talk</a></strong>
                      </h6>
                    </div>
                  </div>
                
                
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 13, 2017
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/happy-birthday-clojure/">Happy birthday Clojure!</a></strong>
                      </h6>
                    </div>
                  </div>
                
                
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 10, 2017
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/use-clojure-already/">Just use Clojure already!</a></strong>
                      </h6>
                    </div>
                  </div>
                
                
              </div>
            </div>
          </div>
          <hr>
        <!-- Hypothes.is -->
<script type="application/json" class="js-hypothesis-config">
    {"showHighlights": false}
</script>
<script src="https://hypothes.is/embed.js" async></script>
        </div>
      </div>
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/arnaudbos/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>

<div class="scroll-to-top">
  <a href="#">Scroll<br>to Top</a>
</div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://i-rant.arnaudbos.com/js/docs.min.js"></script>
<script src="https://i-rant.arnaudbos.com/js/main.js"></script>

<script src="https://i-rant.arnaudbos.com/js/ie10-viewport-bug-workaround.js"></script>

<!-- EmojiOne -->
<script src="https://cdn.jsdelivr.net/emojione/2.2.7/lib/js/emojione.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/emojione/2.2.7/assets/css/emojione.min.css"/>

<script>
(function (){
  var emojis = document.getElementsByClassName('emoji');
  for(var i=0; i<emojis.length; i++){
	  var content = emojis[i].textContent;
    emojis[i].innerHTML = emojione.shortnameToImage(content);
  }
})();
</script>

<!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/languages/clojure.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<link rel="stylesheet" type="text/css" href="/css/klipse-theme.css">
<script>
    window.klipse_settings = {
        selector: '.language-klipse',
        codemirror_options_in: {
          theme: "twilight",
          lineWrapping: false,
          lineNumbers: true,
          autoCloseBrackets: true
        },
        codemirror_options_out: {
          theme: "twilight",
          lineWrapping: false,
          lineNumbers: true
        }
    };
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>


<link rel="stylesheet" href="/css/photoswipe.css">
<link rel="stylesheet" href="/css/default-skin/default-skin.css">
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>
<script src="/js/initphotoswipe.js"></script>



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<style>
    .gallery { float: right; margin-bottom: 10px; text-align: center; }
    .gallery img { height: auto; }
    .gallery .title { text-align: center; text-decoration: underline; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; }
    .gallery figcaption { display: none; }
</style>

<script>initPhotoSwipeFromDOM('.gallery');</script>







  </body>
</html>
