<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arnaud Bos</title>
    <link>http://www.arnaudbos.com/categories/java/index.xml</link>
    <description>Recent content on Arnaud Bos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="http://www.arnaudbos.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2D transformations with Matrices for Java and Android developers</title>
      <link>http://www.arnaudbos.com/matrices-java-and-android/</link>
      <pubDate>Sat, 19 Nov 2016 15:08:29 +0100</pubDate>
      
      <guid>http://www.arnaudbos.com/matrices-java-and-android/</guid>
      <description>

&lt;p&gt;A few weeks ago I was on an &lt;code&gt;android-user-group&lt;/code&gt; channel,
when someone posted a question about Android&amp;rsquo;s
&lt;a href=&#34;https://developer.android.com/reference/android/graphics/Matrix.html#postScale(float,%20float,%20float,%20float)&#34;&gt;Matrix.postScale(sx, sy, px, py)&lt;/a&gt; method and how it works
because it was &lt;em&gt;&amp;ldquo;hard to grasp&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Coincidence: a few months ago, at the beginning of 2016, I finished a freelance
project on an &lt;a href=&#34;https://play.google.com/store/apps/details?id=fr.climbingaway&#34;&gt;Android application&lt;/a&gt; where I had to implement
an exciting feature:&lt;/p&gt;

&lt;p&gt;The user, after buying and downloading a digital topography of a crag, had
be able to view the crag which was composed of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a picture of the cliff,&lt;/li&gt;
&lt;li&gt;a SVG file containing the overlay of the climbing routes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The user had to have the ability to pan and zoom at will and have the routes
layer &amp;ldquo;&lt;em&gt;follow&lt;/em&gt;&amp;rdquo; the picture.&lt;/p&gt;

&lt;p&gt;In order to do this, the SVG parser had to build a tree of objects representing
SVG DOM elements, down to the &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;polyline&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;rect&lt;/code&gt;,
&lt;code&gt;circle&lt;/code&gt; and &lt;code&gt;ellipse&lt;/code&gt; elements, respectively represented in Android as
&lt;code&gt;android.graphics&lt;/code&gt; objects.&lt;/p&gt;

&lt;p&gt;Nothing fancy here (except the parsing part): the first four can be drawn using
a &lt;code&gt;Path&lt;/code&gt; only, and the remaining three are just special drawing methods based on
the &lt;code&gt;RectF&lt;/code&gt; specification.&lt;/p&gt;

&lt;p&gt;I will not enter into the performance optimization twists I (modestly) made
here, but feel free to contact me to discuss the matter and I&amp;rsquo;ll write a
follow-up post on the subject.&lt;/p&gt;

&lt;h2 id=&#34;now-the-interesting-stuff&#34;&gt;Now the interesting stuff&lt;/h2&gt;

&lt;p&gt;In order to have the overlay of routes follow the user&amp;rsquo;s actions, I had to
apply 2D transformations, that is &lt;code&gt;android.graphics.Matrix&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The problem with this class, is that if you have no mathematical background,
it&amp;rsquo;s quite mysterious what it does.&lt;/p&gt;

&lt;p&gt;So at this very moment of the development process I realized I&amp;rsquo;d needed
basic math skills about &lt;a href=&#34;https://en.wikipedia.org/wiki/Matrix_(mathematics)&#34;&gt;matrices&lt;/a&gt; I had forgotten many years prior,
after finishing my first two years of uni ðŸ˜±&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Google to the rescue!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While searching around I&amp;rsquo;ve found a number of good resources and was able to
learn some math again, and it felt great. It also helped me solve my 2D
transformations problems by applying my understandings as code in Java and
Android.&lt;/p&gt;

&lt;p&gt;So, given the discussion I&amp;rsquo;ve had on the channel I&amp;rsquo;ve mentioned above, it
seems I was not the only one struggling with matrices, trying to make sense of
it and using these skills with Android&amp;rsquo;s Matrix class and methods,
so I thought I&amp;rsquo;d write an article.&lt;/p&gt;

&lt;h2 id=&#34;the-plan&#34;&gt;The plan&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Matrices basics&lt;/strong&gt;: A lot of links and videos to &lt;em&gt;go&lt;/em&gt; learn matrices algebra&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transformation matrices&lt;/strong&gt;: A deeper dive into matrices for 2D
transformations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Types of transformations&lt;/strong&gt;: We define the different types of
transformations and define a 2x2 matrix for each&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2D transformations with 3x3 matrices&lt;/strong&gt;: We define our transformation
matrices as 3x3 matrices&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Matrices wrap-up&lt;/strong&gt;: A quick summary of the matrices we&amp;rsquo;ve seen in previous
sections&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Affine transformations with Java&lt;/strong&gt;: Use &lt;code&gt;java.awt.geom.AffineTransform&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Affine transformations with Android&lt;/strong&gt;: Use &lt;code&gt;android.graphics.Matrix&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;matrices-basics&#34;&gt;Matrices basics&lt;/h2&gt;

&lt;p&gt;The first resource you might encounter when trying to understand affine
transformations is Wikipedia:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations&#34;&gt;https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Affine_transformation&#34;&gt;https://en.wikipedia.org/wiki/Affine_transformation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this material, I almost gotâ€”wait&amp;hellip;&lt;/p&gt;


&lt;figure  &gt;
    
        &lt;img src=&#34;http://www.arnaudbos.com/img/matrices-java-and-android/awkward-seal.png&#34; alt=&#34;Awkward seal&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;NOPE, nevermind, I didn&amp;rsquo;t get anything at all.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s hope: on &lt;strong&gt;&lt;em&gt;Khan Academy&lt;/em&gt;&lt;/strong&gt; you will find a very well taught
&lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices&#34;&gt;algebra course about matrices&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you have this kind of problem, I encourage you to take the time needed to
follow this course until you reach that &amp;ldquo;AHA&amp;rdquo; moment. It&amp;rsquo;s just a few hours of
investment (it&amp;rsquo;s free) and you won&amp;rsquo;t regret it. Plus, I will
point you to the parts in particular that helped me.&lt;/p&gt;

&lt;h3 id=&#34;what-is-a-matrix&#34;&gt;What is a matrix?&lt;/h3&gt;

&lt;p&gt;Well, you&amp;rsquo;ll find out by watching this video and &lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-intro-to-matrices/a/intro-to-matrices&#34;&gt;the accompanying course here&lt;/a&gt;.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/0oGJTQCy4cQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;So a matrix is an array of numbers, fantastic. Now what can we do with it?&lt;/p&gt;

&lt;p&gt;We can define an algebra for it: like
&lt;a href=&#34;https://www.khanacademy.org/bigbingo_redirect?continue=https%3A%2F%2Fwww.khanacademy.org%2Fmath%2Falgebra-home%2Falg-matrices%2Falg-adding-and-subtracting-matrices%2Fv%2Fmatrix-addition-and-subtraction-1&amp;amp;conversion_ids=condensed_tutorial_title_click&#34;&gt;addition, subtraction&lt;/a&gt; and multiplication operations,
for fun and profit. ðŸ¤“&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spoiler alert&lt;/strong&gt;: for 2D transformations you&amp;rsquo;ll be more interested in
multiplication than addition/subtraction, but I really encourage you to follow
the whole course, it&amp;rsquo;s worth it.&lt;/p&gt;

&lt;h3 id=&#34;matrix-multiplication&#34;&gt;Matrix multiplication&lt;/h3&gt;

&lt;p&gt;Still reading? Ok, &lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-multiplying-matrices-by-matrices/a/multiplying-matrices&#34;&gt;let&amp;rsquo;s multiply matrices&lt;/a&gt;:&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/kT4Mp9EdVqs&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;The bad news: &lt;strong&gt;&lt;em&gt;you can&amp;rsquo;t always multiply two matrices&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Just as there&amp;rsquo;s a rule for adding/subtracting two matrices (the two matrices
must have the same dimensions), there&amp;rsquo;s a rule for multiplying two matrices:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In order for matrix multiplication to be defined, the number of columns in
the first matrix must be equal to the number of rows in the second matrix.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Otherwise you just &lt;strong&gt;can&amp;rsquo;t&lt;/strong&gt; multiply, period.&lt;/p&gt;

&lt;p&gt;More details &lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-properties-of-matrix-multiplication/v/defined-and-undefined-matrix-operations&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-properties-of-matrix-multiplication/a/matrix-multiplication-dimensions&#34;&gt;here&lt;/a&gt; if you
are interested.&lt;/p&gt;

&lt;h2 id=&#34;transformation-matrices&#34;&gt;Transformation matrices&lt;/h2&gt;

&lt;p&gt;Now that we know what is a matrix and how we can multiply matrices, we can see
why it is interesting for &lt;strong&gt;2D transformations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The next video will show you how you can use a matrix to &lt;strong&gt;transform a point&lt;/strong&gt;!&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/Kh8HKAxdEyw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Or &lt;strong&gt;a series of points&lt;/strong&gt;!&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/RKBSX-6pKgY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Notice the nature of the transformation is not clear yet, the transformation
matrix was picked at random, and yet we see how interesting and useful it is
for 2D manipulation of graphics.&lt;/p&gt;

&lt;p&gt;For now, I suppose all you know is the type of transformations you want to
apply: &lt;code&gt;rotation&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt; or &lt;code&gt;translation&lt;/code&gt; and the parameters.&lt;/p&gt;

&lt;p&gt;So how do you go from &lt;code&gt;scale by a factor of 2&lt;/code&gt; and &lt;code&gt;rotate 90 degrees clockwise&lt;/code&gt;
to a transformation matrix?&lt;/p&gt;

&lt;p&gt;Well the answer is:&lt;/p&gt;


&lt;figure  &gt;
    
        &lt;img src=&#34;http://www.arnaudbos.com/img/matrices-java-and-android/moar-math-stuff.jpg&#34; alt=&#34;Moar math stuff with smiling cat meme&#34;
            width=&#34;60%&#34;
            /&gt;
    
    
&lt;/figure&gt;



&lt;h3 id=&#34;more-math-stuff&#34;&gt;More math stuff&lt;/h3&gt;

&lt;p&gt;More particularly you&amp;rsquo;ll need to read &lt;a href=&#34;https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-matrices-as-transformations/a/matrices-as-transformations&#34;&gt;this course on &lt;em&gt;Matrices as
transformations&lt;/em&gt; (which is full of fancy plots and
animations)&lt;/a&gt; and particularly its last part:
&lt;strong&gt;&lt;em&gt;Representing two dimensional linear transforms with matrices&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Come back here once you&amp;rsquo;ve read it, or it&amp;rsquo;s gonna hurt ðŸ˜…&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ok I suppose you&amp;rsquo;ve read the course I linked to above, so in this course we&amp;rsquo;ve
learned that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a position vector &lt;code&gt;$ \begin{bmatrix} x\\  y \end{bmatrix} $&lt;/code&gt; can be broken down as &lt;code&gt;$ \begin{bmatrix} x\\ y \end{bmatrix} = x \begin{bmatrix} \color{Green} 1\\ \color{Green} 0 \end{bmatrix} + y \begin{bmatrix} \color{Red} 0\\ \color{Red} 1 \end{bmatrix} $&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;we&amp;rsquo;ve also learned that
&lt;code&gt;$ \begin{bmatrix} \color{Green} a\\ \color{Green} c \end{bmatrix} $&lt;/code&gt; and &lt;code&gt;$ \begin{bmatrix} \color{Red} b\\ \color{Red} d \end{bmatrix} $&lt;/code&gt; are the position vectors where &lt;code&gt;$ \begin{bmatrix} \color{Green} 0\\ \color{Green} 1 \end{bmatrix} $&lt;/code&gt; and &lt;code&gt;$ \begin{bmatrix} \color{Red} 1\\ \color{Red} 0 \end{bmatrix} $&lt;/code&gt; will land respectively after the matrix &lt;code&gt;$ \mathbf{A} = \begin{bmatrix} \color{Green} a &amp;amp; \color{Red} b\\ \color{Green} c &amp;amp; \color{Red} d \end{bmatrix} $&lt;/code&gt; has been applied.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;and that given the same transformation, &lt;code&gt;$ \begin{bmatrix} x\\ y \end{bmatrix} $&lt;/code&gt; will land on &lt;code&gt;$ \begin{bmatrix} \color{Green} a x + \color{Red} b x\\ \color{Green} c x + \color{Red} d y \end{bmatrix} $&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you don&amp;rsquo;t understand this conclusion, read again, take your time.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Now remember, our goal is to determine what &lt;code&gt;$ \mathbf{A} $&lt;/code&gt; is, because we
know the transformation we want to apply but we&amp;rsquo;re searching for the matrix we
should apply to our position vector(s) in order to transform our graphics.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take the example of the series of points transformation video above
and turn the problem backward: we know where the position vectors will land,
but we&amp;rsquo;re looking for &lt;code&gt;$ \mathbf{A} $&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; Insert 2D plane with &lt;code&gt;$P_{(2,1)}$&lt;/code&gt;, &lt;code&gt;$Q_{(-2,0)}$&lt;/code&gt;, &lt;code&gt;$P&#39;_{(5, 0)}$&lt;/code&gt;
and &lt;code&gt;$Q&#39;_{(-4, 2)}$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We know that:&lt;/p&gt;

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;`$$ \begin{bmatrix} 2\\ 1 \end{bmatrix} \text{ lands on } \begin{bmatrix} 5\\ 0 \end{bmatrix} $$`&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;`$$ \begin{bmatrix} -2\\ 0 \end{bmatrix} \text{ lands on } \begin{bmatrix} -4\\ 2 \end{bmatrix} $$`&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

Which means:

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;`$$ \begin{bmatrix} x\\ y \end{bmatrix} = \begin{bmatrix} 2\\ 1 \end{bmatrix} \text{ lands on } \begin{bmatrix} a.x+b.y\\ c.x+d.y \end{bmatrix} = \begin{bmatrix} 5\\ 0 \end{bmatrix} $$`&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;`$$ \begin{bmatrix} x\\ y \end{bmatrix} = \begin{bmatrix} -2\\ 0 \end{bmatrix} \text{ lands on } \begin{bmatrix} a.x+b.y\\ c.x+d.y \end{bmatrix} = \begin{bmatrix} -4\\ 2 \end{bmatrix} $$`&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

From which we can deduce:

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;`$$ \begin{bmatrix} 2.a+1.b\\ 2.c+1.d \end{bmatrix} = \begin{bmatrix} 5\\ 0 \end{bmatrix} $$`&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;`$$ \begin{bmatrix} -2.a+0.b\\ -2.c+0.d \end{bmatrix} = \begin{bmatrix} -4\\ 2 \end{bmatrix} $$`&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The right side gives us `$ a=2 $` and `$ c = -1 $`, with which we can deduce
`$ b=1 $` and `$ d=2 $` from the left side.

**And this, is our transformation matrix**:

&lt;div&gt;$$ \mathbf{A} = \begin{bmatrix} \color{Green} 2 &amp; \color{Red} 1\\ \color{Green} -\color{Green} 1 &amp; \color{Red} 2 \end{bmatrix} $$&lt;/div&gt;

### The identity matrix

We don&#39;t know how to define a transformation matrix yet, but we know its form.  
So what do we do next? Remember the last section where we&#39;ve seen that
a position vector `$ \begin{bmatrix} x\\  y \end{bmatrix} $` can be
broken down as `$
\begin{bmatrix}
x\\
y
\end{bmatrix}
= x \begin{bmatrix}
\color{Green} 1\\
\color{Green} 0
\end{bmatrix}
+ y \begin{bmatrix}
\color{Red} 0\\
\color{Red} 1
\end{bmatrix} $` ?

That&#39;s a pretty good starting point, we just laid out our &#34;base&#34; matrix:

&lt;div&gt;
$$
\begin{bmatrix}
\color{Green} 1 &amp; \color{Red} 0\\
\color{Green} 0 &amp; \color{Red} 1
\end{bmatrix}
$$
&lt;/div&gt;

This matrix represents the base state of your plane, the matrix applied
to your plane when you have just loaded your image for example (granted
your image is the same size as its receiving container view).  
In other words, ***this is the matrix that, applied to a position vector will
return that same position vector***.

This matrix is called [the identity matrix][khan-identity-matrix]:


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/3cnIa0fYJkY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;br&gt;

### Combining transformations

One more thing before we get concrete: *We want our user to be able
to combine/chain transformations* (like zooming and panning at the same time
for instance).

In order to chain multiple transformations we need to understand the
[properties of matrix multiplication][khan-mult-properties], and more
specifically the `non-commutative` and `associative` properties of matrix
multiplication.

Let&#39;s take yet another example:  
Imagine we want to apply transformations `$ \mathbf{B} $`, then transformation
`$ \mathbf{A} $` to our position vector `$ \vec{v} $`.

We have
`$
\vec{v&#39;} = \mathbf{B} . \vec{v}
$`
and
`$
\vec{v&#39;&#39;} = \mathbf{A} . \vec{v&#39;}
$`,
which leads us to:

&lt;div&gt;
$$
\vec{v&#39;&#39;} = \mathbf{A} . \left( \mathbf{B} . \vec{v} \right)
$$
&lt;/div&gt;

From the previous link on matrix properties, we know that matrix multiplication
is `associative`, which gives us:


&lt;div&gt;
$$
\vec{v&#39;&#39;} = \mathbf{A} . \left( \mathbf{B} . \vec{v} \right)
\Leftrightarrow
\vec{v&#39;&#39;} = \left( \mathbf{A} . \mathbf{B} \right) . \vec{v}
$$
&lt;/div&gt;

In conclusion, in order to apply multiple transformations at once, we can
multiply all our transformation matrices and apply the resulting transformation
matrix to our vector(s).

The previous link also taught us that matrix multiplication is **not**
commutative, so the order in which we multiply our transformation matrices
(`$ \mathbf{A} . \mathbf{B} $` or `$ \mathbf{B} . \mathbf{A} $`) will have
an impact on our final matrix and will lead to results, different
transformations.

## Types of transformations

There are several types of 2D transformations we are able to define using 2x2
dimensions matrices, and you&#39;ve had a preview of most of them in this
course on [matrices as transformations][khan-matrices-transform].  
Namely:

* Scaling
* Reflexion
* Shearing
* Rotation

For the rest of this section imagine we have the point
`$ P_{\left(x, y\right)} $`, which represents any point of
an object on the plane, and we want to find the matrix to transform it into
`$ P&#39;_{\left(x&#39;, y&#39;\right)}$` such that

&lt;div&gt;
$$
\begin{bmatrix} x&#39;\\y&#39; \end{bmatrix} =
\mathbf{A} . \begin{bmatrix} x\\y \end{bmatrix} =
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
.
\begin{bmatrix} x\\y \end{bmatrix}
$$
&lt;/div&gt;

### Scaling

Scaling (like zooming in by a factor of 2 for instance) might seem
straightforward to represent at the time of pinch-zoom/digital devices, right?
*&#34;Simply multiply the coordinates by the scaling factor and you&#39;re done.&#34;*  
But the pitfall here is that you *might* want to have different horizontal and
vertical scaling factors for your transformation, I mean it&#39;s possible!

So we must differentiate between `$ s_{x} $` and `$ s_{y} $` which represent
the horizontal and vertical scaling factors, respectively.

The two equations this gives us are:

&lt;div&gt;
$$
x&#39; = s_{x} . x \\
y&#39; = s_{y} . y
$$
&lt;/div&gt;

Knowing that:

&lt;div&gt;
$$
\begin{bmatrix} x&#39;\\y&#39; \end{bmatrix} =
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
.
\begin{bmatrix} x&#39;\\y&#39; \end{bmatrix}
$$
&lt;/div&gt;

We can find `$a$`, `$b$`, `$c$` and `$d$`:

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
s_{x} . x = a . x + b . y\\
\Rightarrow
a = s_{x} \text{ and } b = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
s_{y} . y = c . x + d . y\\
\Rightarrow
c = s_{y} \text{ and } d = 0
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

In conclusion, the 2x2 scaling matrix for the factors
`$ \left(s_{x}, s_{y}\right) $` is

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix} s_{x} &amp; 0\\0 &amp; s_{y} \end{bmatrix}
$$
&lt;/div&gt;

Which makes sense, right? I mean, scaling by a factor of `$1$` both on the
`$x$` and `$y$` axises will give:

&lt;div&gt;
$$
\begin{bmatrix} s_{x} &amp; 0\\0 &amp; s_{y} \end{bmatrix}
=
\begin{bmatrix} 1 &amp; 0\\0 &amp; 1 \end{bmatrix}
$$
&lt;/div&gt;

Which is... the `identity` matrix! So nothing moves, basically.

### Reflexion

There are 2 types of reflexions we can think about right ahead: reflexion around
an axis, or around a point.  
To keep things simple we&#39;ll focus on reflexions around the `$x$` and `$y$`
axises (reflexion around the origin is the equivalent of applying a reflexion on
the `$x$` and `$y$` axises successively).

Reflexion around the `$x$` axis gives us:

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = x\\
\Rightarrow
x = a . x + b . y\\
\Rightarrow
a = 1 \text{ and } b = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
y&#39; = -y\\
\Rightarrow
-y = c . x + d . y\\
\Rightarrow
c = 0 \text{ and } d = -1
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

Funny, reflecting around the `$x$` axis is the same transformation as scaling
`$x$` by a factor of `$-1$` and `$y$` by a factor of `$1$`:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0\\
0 &amp; -1
\end{bmatrix}
$$
&lt;/div&gt;

And reflexion around the `$y$` axis gives us:

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = -x\\
\Rightarrow
-x = a . x + b . y\\
\Rightarrow
a = -1 \text{ and } b = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
y&#39; = y\\
\Rightarrow
y = c . x + d . y\\
\Rightarrow
c = 0 \text{ and } d = 1
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The transformation matrix to reflect around the `$y$` axis is:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix}
-1 &amp; 0\\
0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

### Shearing

Now it gets a little bit trickier.

In most examples I&#39;ve found, shearing is explained by saying the coordinates
are changed by adding a constant that measures the degree of shearing.  
For instance, a shear along the `$x$` axis is often represented showing a
rectangle with a vertex at `$\left(0, 1\right)$` is transformed into a
parallelogram with a vertex at `$\left(1, 1\right)$`.

TODO: (insert image of a plane with a shearing of alpha)

In this article, I want to explain it using the shearing angle, the angle
through which the axis is sheared. Let&#39;s call it `$\alpha$` (alpha).

Remember your [trigonometry][trigonometry] class?

&gt; In a right-angled triangle:
&gt;
&gt; * the hypotenuse is the longest side
&gt; * the the opposite side is the one at the opposite of a given angle
&gt; * the adjacent side is the next to a given angle

If we look at the plane above, we can see that the new abscissa `$x&#39;$` is
equals to the addition of `$x$` plus the opposite side of the triangle formed
by the `$y$` axis, the sheared version of the `$y$` axis and the segment
between the top left vertex of the rectangle and the top left vertex of the
parallelogram.

From our trigonometry class, we know that:

&lt;div&gt;
$$
\cos \left( \alpha \right) = \frac{adjacent}{hypotenuse}\\
\sin \left( \alpha \right) = \frac{opposite}{hypotenuse}\\
\tan \left( \alpha \right) = \frac{opposite}{adjacent}
$$
&lt;/div&gt;

We know `$\alpha$`, but we don&#39;t know the length of the hypotenuse, so we
can&#39;t use the cosine function.  
But we know the adjacent side&#39;s length: it&#39;s `$y$`, so we can use the tangent
function find the opposite side&#39;s length.

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = x + y . \tan \left( -\alpha \right) \\
\Rightarrow
x + y . \tan \left( -\alpha \right) = a . x + b . y\\
\Rightarrow
a = 1 \text{ and } b = \tan \left( -\alpha \right)
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
y&#39; = y\\
\Rightarrow
y = c . x + d . y\\
\Rightarrow
c = 0 \text{ and } d = 1
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The transformation matrix to shear along the `$x$` direction is:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix}
1 &amp; \tan \left( -\alpha \right)\\
0 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; k_{x}\\
0 &amp; 1
\end{bmatrix}\\
\text{where } k_{x} \text{ is the shearing constant}
$$
&lt;/div&gt;

Similarly, the transformation matrix to shear along the `$y$` direction is:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0\\
\tan \left( -\beta \right) &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0\\
k_{y} &amp; 1
\end{bmatrix}\\
\text{where } k_{y} \text{ is the shearing constant}
$$
&lt;/div&gt;

### Rotation

Rotations are yet a little bit more complex.

Let&#39;s take a closer look at it with an example of rotating (around the origin)
from a angle `$ \theta $` (theta).

&lt;a title=&#34;By Nick Berry&#34; href=&#34;http://datagenetics.com/blog/august32013/&#34;&gt;&lt;img style=&#34;background-color: #333;&#34;
src=&#34;/img/matrices-java-and-android/g22.png&#34;&gt;&lt;/a&gt;

This image shows a point `$ P $` before and after a rotation: `$ P $`
in the starting and ending planes respectively.

Notice how the coordinates of `$ P $` in each plane are the same:
`$ P $` has the same set of coordinates `$ \left( x, y\right) $` in both
planes.  
But now `$ P $` has ***new coordinates*** `$ \left( x, y\right) $` ***in the
first plane***.

Let&#39;s rename the coordinates of `$ P $` in the second plane as
`$ \left( x&#39;, y&#39;\right) $`.
At this point we know `$ x&#39; $` and `$ y&#39; $`, because they are the same as the
original `$ x $` and `$ y $`. But we don&#39;t know the new `$ x $` and `$ y $`.  
On the other hand, we can now define the ***relationship*** between the new
coordinates `$ \left(x, y\right) $` and the coordinates in the rotated plane
`$ \left(x&#39;, y&#39;\right) $`, right?

This is where [trigonometry][trigonometry] helps again, along with
[this post][datagenetics-rotation] and [this video][matrix-rotation-video].

&lt;a title=&#34;By Nick Berry&#34; href=&#34;http://datagenetics.com/blog/august32013/&#34;&gt;&lt;img style=&#34;background-color: #333;&#34;
src=&#34;/img/matrices-java-and-android/g32.png&#34;&gt;&lt;/a&gt;

Here we see that `$ x&#39; $` (the blue line) can be expressed as the addition of
the
&lt;span class=&#34;green-text&#34;&gt;adjacent side of the green triangle&lt;/span&gt;
plus
&lt;span class=&#34;red-text&#34;&gt;the opposite side of the red triangle.&lt;/span&gt;  
And `$ y&#39; $` as the subtraction of
&lt;span class=&#34;green-text&#34;&gt;the opposite side of the green triangle&lt;/span&gt;
from
&lt;span class=&#34;red-text&#34;&gt;the adjacent side of the red triangle&lt;/span&gt;.

&lt;div&gt;
$$
\cos \left( \theta \right) = \frac{adjacent}{hypotenuse} \Rightarrow adjacent = hypotenuse . \cos \left( \theta \right)\\
\sin \left( \theta \right) = \frac{opposite}{hypotenuse} \Rightarrow opposite = hypotenuse . \sin \left( \theta \right)
$$
&lt;/div&gt;

So we can express our relationship as follows:

&lt;div&gt;
$$
\begin{align}
x&#39; &amp; = \color{Green}a\color{Green}d\color{Green}j\color{Green}a\color{Green}c\color{Green}e\color{Green}n\color{Green}t + \color{Red}o\color{Red}p\color{Red}p\color{Red}o\color{Red}s\color{Red}i\color{Red}t\color{Red}e\\
&amp; = \color{Green}h\color{Green}y\color{Green}p\color{Green}o\color{Green}t\color{Green}e\color{Green}n\color{Green}u\color{Green}s\color{Green}e . \cos \left( \theta \right) + \color{Red}h\color{Red}y\color{Red}p\color{Red}o\color{Red}t\color{Red}e\color{Red}n\color{Red}u\color{Red}s\color{Red}e . \sin \left( \theta \right)\\
&amp; = x . \cos \left( \theta \right) + y . \sin \left( \theta \right)
\end{align}
$$
&lt;/div&gt;

and:

&lt;div&gt;
$$
\begin{align}
y&#39; &amp; = \color{Red}a\color{Red}d\color{Red}j\color{Red}a\color{Red}c\color{Red}e\color{Red}n\color{Red}t - \color{Green}o\color{Green}p\color{Green}p\color{Green}o\color{Green}s\color{Green}i\color{Green}t\color{Green}e\\
&amp; = \color{Red}h\color{Red}y\color{Red}p\color{Red}o\color{Red}t\color{Red}e\color{Red}n\color{Red}u\color{Red}s\color{Red}e . \cos \left( \theta \right) - \color{Green}h\color{Green}y\color{Green}p\color{Green}o\color{Green}t\color{Green}e\color{Green}n\color{Green}u\color{Green}s\color{Green}e . \sin \left( \theta \right)\\
&amp; = y . \cos \left( \theta \right) - x . \sin \left( \theta \right)\\
&amp; = -x . \sin \left( \theta \right) + y . \cos \left( \theta \right)
\end{align}
$$
&lt;/div&gt;

In the end what we really have here is a system of equations that we can
represent as a 2x2 matrix:

&lt;div&gt;
$$
\begin{bmatrix}
x&#39;\\
y&#39;
\end{bmatrix}
=
\begin{bmatrix}
\cos \left( \theta \right) &amp; \sin \left( \theta \right)\\
-\sin \left( \theta \right) &amp; \cos \left( \theta \right)
\end{bmatrix}
.
\begin{bmatrix}
x\\
y
\end{bmatrix}
$$
&lt;/div&gt;

But this is not *exactly* what we are looking for, right?  
This defines the relationship to convert from the *new* coordinates in the
original plane
`$ \left(x, y\right) $`
what are the coordinates `$ \left(x&#39;, y&#39;\right) $` in the rotated plane.  
Whereas what we want to define is how to convert from the rotated plane
(the coordinates that we know) to the original plane.

In order to do what we want, we need to take the same matrix, but define a
rotation of `$ - \theta $`.

We know that:

&lt;div&gt;
$$
\cos \left( -\theta \right) = cos \left( \theta \right)\\
\sin \left( -\theta \right) = - sin \left( \theta \right)
$$
&lt;/div&gt;

Which gives us our desired rotation matrix:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b\\c &amp; d \end{bmatrix}
=
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right)\\
\sin \left( \theta \right) &amp; \cos \left( \theta \right)
\end{bmatrix}
$$
&lt;/div&gt;

Congratulations! You know of to define scaling, reflexion, shearing and rotation
transformation matrices. So what is missing?

## 2D transformations with 3x3 matrices

If you&#39;re still with me at this point, maybe you&#39;re wondering why any of this
is useful. If it&#39;s the case, you missed the point of this article, which is to
***understand*** affine transformations in order to apply them in code.

This is useful because at this point you know what a transformation matrix
looks like, and you know how to compute one given a few position vectors,
and it is also a great accomplishment by itself.

But here&#39;s the thing: 2x2 matrices are limiting us in the number of operations
we can perform. With a 2x2 matrix, the only transformations we can do are the
ones we&#39;ve seen in the previous section:

* Scaling
* Reflexion
* Shearing
* Rotation

So what are we missing? Answer: translations!  
And this is unfortunate, as translations are really useful, like when the user
pans and the image has to behave accordingly (aka. *follow the finger*).  
Translations are defined by the addition of two matrices :

&lt;div&gt;
$$
\begin{bmatrix}
x&#39;\\
y&#39;
\end{bmatrix}
=
\begin{bmatrix}
x\\
y
\end{bmatrix}
+
\begin{bmatrix}
t_{x}\\
t_{y}
\end{bmatrix}
$$
&lt;/div&gt;

But we want our user to be able to combine/chain transformations (like
zooming on a specific point which is not the origin), so we need to find a
way to express translations as matrices multiplications too.

Here comes the world of [Homogeneous coordinates][homogeneous-coordinates]...

**No, you don&#39;t *have* to read it**, and no I don&#39;t totally get it either...

The gist of it is:

* the Cartesian plane you&#39;re used to, is really just one of the multiple
  planes that exist in the 3D space, and is at `$ z = 1 $`
* for any point `$ \left(x, y, z\right)$` in the 3D space, the line in
  the projecting space that is going through this point and the origin is
  also passing through any point that is obtained by scaling
  `$x$`, `$y$` and `$z$` by the same factor
* the coordinates of any of these points on the line is
  `$ \left(\frac{x}{z}, \frac{y}{z}, z\right)$`.

`TODO` Insert projective geometry/homogeneous coordinates 3D plot here

I&#39;ve collected a list of blog posts, articles and videos links at the end of
this post if you&#39;re interested.

Without further dig in, this is helping, because it says that we
can now represent any point in our Cartesian plane (`$ z = 1 $`) not only as
a 2x1 matrix, but also as a 3x1 matrix:

&lt;div&gt;
$$
\begin{bmatrix}
x\\
y
\end{bmatrix}
\Leftrightarrow
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}
$$
&lt;/div&gt;

Which means we have to redefine all our previous transformation matrices,
because the product of a 3x1 matrix (position vector) by a 2x2 matrix
(transformation) is *undefined*.

**Don&#39;t rage quit! It&#39;s straightforward: `$z&#39;=z$`.**

We have to find the transformation matrix `$
\mathbf{A} =
\begin{bmatrix} a &amp; b &amp; c\\ d &amp; e &amp; f\\ g &amp; h &amp; i \end{bmatrix}
$`

If, like in the previous section, we imagine that we have the point
`$ P_{\left(x, y, z\right)} $`, which represents any point of
an object on the cartesian plane, then we want to find the matrix to transform
it into `$ P&#39;_{\left(x&#39;, y&#39;, z&#39;\right)}$` such that

&lt;div&gt;
$$
\begin{bmatrix} x&#39;\\y&#39;\\z&#39; \end{bmatrix} =
\mathbf{A} . \begin{bmatrix} x\\y\\z \end{bmatrix} =
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
.
\begin{bmatrix} x\\y\\z \end{bmatrix}
$$
&lt;/div&gt;


### Scaling

&lt;section class=&#34;split-third&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = s_{x} . x\\
\Rightarrow
s_{x} . x = a . x + b . y + c . z\\
\Rightarrow
a = s_{x} \text{ and } b = 0 \text{ and } c = 0
$$`
    &lt;/div&gt;
    &lt;div class=&#34;middle&#34;&gt;
`$$
y&#39; = s_{y} . y\\
\Rightarrow
s_{y} . y = d . x + e . y + f + z\\
\Rightarrow
d = s_{y} \text{ and } e = 0 \text{ and } f = 0
$$`
    &lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
z&#39; = z\\
\Rightarrow
z = g . x + h . y + i + z\\
\Rightarrow
g = 0 \text{ and } h = 0 \text{ and } i = 1
$$`
    &lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The 3x3 scaling matrix for the factors
`$ \left(s_{x}, s_{y}\right) $` is

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix} s_{x} &amp; 0 &amp;0\\0 &amp; s_{y} &amp; 0\\0 &amp; 0 &amp; 1\end{bmatrix}
$$
&lt;/div&gt;

### Reflexion

Reflexion around the `$x$` axis:

&lt;section class=&#34;split-third&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = x\\
\Rightarrow
x = a . x + b . y + c . z\\
\Rightarrow
a = 1 \text{ and } b = 0 \text{ and } c = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;middle&#34;&gt;
`$$
y&#39; = -y\\
\Rightarrow
-y = d . x + e . y + f . z\\
\Rightarrow
d = 0 \text{ and } e = -1 \text{ and } f = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
z&#39; = z\\
\Rightarrow
z = g . x + h . y + i . z\\
\Rightarrow
g = 0 \text{ and } h = 0 \text{ and } i = 1
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The transformation matrix to reflect around the `$x$` axis is:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; -1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

Reflexion around the `$y$` axis:

&lt;section class=&#34;split-third&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = -x\\
\Rightarrow
-x = a . x + b . y + c . z\\
\Rightarrow
a = -1 \text{ and } b = 0 \text{ and } c = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;middle&#34;&gt;
`$$
y&#39; = y\\
\Rightarrow
y = d . x + e . y + f . z\\
\Rightarrow
d = 0 \text{ and } e = 1 \text{ and } f = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
z&#39; = z\\
\Rightarrow
z = g . x + h . y + i . z\\
\Rightarrow
g = 0 \text{ and } h = 0 \text{ and } i = 1
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

The transformation matrix to reflect around the `$y$` axis is:

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix}
-1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

### Shearing

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
`$$
x&#39; = x + y . \tan \left( -\alpha \right) \\
\Rightarrow
x + y . \tan \left( -\alpha \right) = a . x + b . y + c . z\\
\Rightarrow
a = 1 \text{ and } b = \tan \left( -\alpha \right) \text{ and } c = 0
$$`
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
y&#39; = y\\
\Rightarrow
y = d . x + e . y + f . z\\
\Rightarrow
d = 0 \text{ and } e = 1 \text{ and } f = 0
$$`
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;

&lt;section class=&#34;split-half&#34;&gt;
    &lt;div class=&#34;right&#34;&gt;
`$$
z&#39; = z\\
\Rightarrow
z = g . x + h . y + i . z\\
\Rightarrow
g = 0 \text{ and } h = 0 \text{ and } i = 1
$$`
&lt;/div&gt;
&lt;/section&gt;

&lt;p&gt;The transformation matrix to shear along the &lt;code&gt;$x$&lt;/code&gt; direction is:&lt;/p&gt;

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix}
1 &amp; \tan \left( -\alpha \right) &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; k_{x} &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
\text{where } k \text{ is the shearing constant}
$$
&lt;/div&gt;

&lt;p&gt;Similarly, the transformation matrix to shear along the &lt;code&gt;$y$&lt;/code&gt; direction is:&lt;/p&gt;

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
\tan \left( -\beta \right) &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
k_{y} &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
\text{where } k \text{ is the shearing constant}
$$
&lt;/div&gt;

&lt;h3 id=&#34;rotating&#34;&gt;Rotating&lt;/h3&gt;

&lt;p&gt;Well, I&amp;rsquo;m a bit lazy here ðŸ¤—&lt;br /&gt;
You see the pattern, right?&lt;/p&gt;

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; 0\\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

&lt;h4 id=&#34;translation&#34;&gt;Translation&lt;/h4&gt;

&lt;p&gt;And now we can define translations as matrices multiplication!&lt;/p&gt;

&lt;p&gt;&lt;section class=&#34;split-third&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
&lt;code&gt;$$
x&#39; = x + t_{x} \\
\Rightarrow
x + t_{x} = a . x + b . y + c . z\\
\Rightarrow
a = 1 \text{ and } b = 0 \text{ and } c = t_{x}
$$&lt;/code&gt;
&lt;/div&gt;
    &lt;div class=&#34;middle&#34;&gt;
&lt;code&gt;$$
y&#39; = y + t_{y}\\
\Rightarrow
y + t_{y} = d . x + e . y + f . z\\
\Rightarrow
d = 0 \text{ and } e = 1 \text{ and } f = t_{y}
$$&lt;/code&gt;
&lt;/div&gt;
    &lt;div class=&#34;right&#34;&gt;
&lt;code&gt;$$
z&#39; = z\\
\Rightarrow
z = g . x + h . y + i . z\\
\Rightarrow
g = 0 \text{ and } h = 0 \text{ and } i = 1
$$&lt;/code&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;The 3x3 translation matrix for the translation
&lt;code&gt;$ \left(t_{x}, t_{y}\right) $&lt;/code&gt; is&lt;/p&gt;

&lt;div&gt;
$$
\begin{bmatrix} a &amp; b &amp; c\\d &amp; e &amp; f\\g &amp; h &amp; i\end{bmatrix}
=
\begin{bmatrix} 1 &amp; 0 &amp; t_{x}\\0 &amp; 1 &amp; t_{y}\\0 &amp; 0 &amp; 1\end{bmatrix}
$$
&lt;/div&gt;

&lt;h2 id=&#34;matrices-wrap-up&#34;&gt;Matrices wrap-up&lt;/h2&gt;

&lt;p&gt;We went into more or less details in the previous sections.&lt;br /&gt;
Obviously, you won&amp;rsquo;t have to go into all of these algebra stuff each
time you want to know what is the matrix you need to apply in order to do
your transformations.&lt;/p&gt;

&lt;p&gt;You can &amp;ldquo;just&amp;rdquo; use the following reminder.&lt;/p&gt;

&lt;p&gt;Translation matrix:
&lt;code&gt;$
\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; t_{x}\\
0 &amp;amp; 1 &amp;amp; t_{y}\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Scaling matrix:
&lt;code&gt;$
\begin{bmatrix}
s_{x} &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; s_{y} &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Shear matrix:
&lt;code&gt;$
\begin{bmatrix}
1 &amp;amp; \tan \left( - \alpha \right) &amp;amp; 0\\
\tan \left( - \beta \right) &amp;amp; 1 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
\text{ = }
\begin{bmatrix}
1 &amp;amp; k_{x} &amp;amp; 0\\
k_{y} &amp;amp; 1 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Rotation matrix:
&lt;code&gt;$
\begin{bmatrix}
\cos \left( \theta \right) &amp;amp; -\sin \left( \theta \right) &amp;amp; 0\\
\sin \left( \theta \right) &amp;amp; \cos \left( \theta \right) &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s neat! Now you can define your matrices easily, plus you know how it
works.&lt;/p&gt;

&lt;p&gt;One last thing: all the transformations we&amp;rsquo;ve seen are &lt;strong&gt;&lt;em&gt;centered around the
origin&lt;/em&gt;&lt;/strong&gt;.&lt;br /&gt;
How do we apply what we know in order to, for instance, zoom on a
specific point which is &lt;strong&gt;not&lt;/strong&gt; the origin, or rotate an object &lt;strong&gt;in place&lt;/strong&gt;,
around its center?&lt;/p&gt;

&lt;p&gt;The answer is &lt;strong&gt;&lt;em&gt;composition&lt;/em&gt;&lt;/strong&gt;: We must &lt;em&gt;compose&lt;/em&gt; our transformations by using
several other transformations.&lt;/p&gt;

&lt;h3 id=&#34;how-to-zoom-on-a-specific-point&#34;&gt;How to zoom on a specific point&lt;/h3&gt;

&lt;p&gt;Imagine you have a shape, like a square for instance, and you want to zoom in
at the center of the square, to mimic a pinch-zoom behaviour.&lt;br /&gt;
This transformation is composed of the following sequence:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;move anchor point to origin: &lt;code&gt;$ \left( -t_{x}, -t_{y} \right) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;scale by &lt;code&gt;$ \left( s_{x}, s_{y} \right) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move back anchor point: &lt;code&gt;$ \left( t_{x}, t_{y} \right) $&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Where &lt;code&gt;$t$&lt;/code&gt; is the anchor point of our scaling transformation (the center of
the square).&lt;/p&gt;

&lt;p&gt;Our transformations are defined by the first translation matrix
&lt;code&gt;$ \mathbf{C} $&lt;/code&gt;, the scaling matrix &lt;code&gt;$ \mathbf{B} $&lt;/code&gt;, and the last
translation matrix &lt;code&gt;$ \mathbf{A} $&lt;/code&gt;.&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{C} =
\begin{bmatrix}
1 &amp; 0 &amp; -t_{x} \\
0 &amp; 1 &amp; -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\text{ , }
\mathbf{B} =
\begin{bmatrix}
s_{x} &amp; 0 &amp; 0 \\
0 &amp; s_{y} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\text{ and }
\mathbf{A} =
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

&lt;p&gt;Because matrix multiplication is non-commutative, the order matters, so we will
apply them in reverse order (hence the reverse naming order).&lt;br /&gt;
The composition of these transformations gives us the following product:&lt;/p&gt;

&lt;div&gt;
$$
\begin{align}
\mathbf{A} . \mathbf{B} . \mathbf{C}
&amp;=
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
s_{x} &amp; 0 &amp; 0 \\
0 &amp; s_{y} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
1 &amp; 0 &amp; -t_{x} \\
0 &amp; 1 &amp; -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
s_{x} &amp; 0 &amp; s_{x} . -t_{x} \\
0 &amp; s_{y} &amp; s_{y} . -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
\mathbf{A} . \mathbf{B} . \mathbf{C}
&amp;=
\begin{bmatrix}
s_{x} &amp; 0 &amp; s_{x} . -t_{x} + t_{x} \\
0 &amp; s_{y} &amp; s_{y} . -t_{y} + t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align}
$$
&lt;/div&gt;

&lt;p&gt;Suppose we have the following points representing a square:
&lt;code&gt;$
\begin{bmatrix}
x_{1} &amp;amp; x_{2} &amp;amp; x_{3} &amp;amp; x_{4}\\
y_{1} &amp;amp; y_{2} &amp;amp; y_{3} &amp;amp; y_{4}\\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{bmatrix}
\text{ = }
\begin{bmatrix}
2 &amp;amp; 4 &amp;amp; 4 &amp;amp; 2\\
1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 3\\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; Insert 2D plot with those 4 points&lt;/p&gt;

&lt;p&gt;And we want to apply a 2x zoom focusing on its center.&lt;br /&gt;
The new coordinates will be:&lt;/p&gt;

&lt;div&gt;
$$
\begin{align}
\begin{bmatrix}
x_{1}&#39; &amp; x_{2}&#39; &amp; x_{3}&#39; &amp; x_{4}&#39;\\
y_{1}&#39; &amp; y_{2}&#39; &amp; y_{3}&#39; &amp; y_{4}&#39;\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
&amp;=
\begin{bmatrix}
s_{x} &amp; 0 &amp; s_{x} . -t_{x} + t_{x} \\
0 &amp; s_{y} &amp; s_{y} . -t_{y} + t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
x_{1} &amp; x_{2} &amp; x_{3} &amp; x_{4}\\
y_{1} &amp; y_{2} &amp; y_{3} &amp; y_{4}\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
2 &amp; 0 &amp; 2 . \left(-3\right) + 3 \\
0 &amp; 2 &amp; 2 . \left(-2\right) + 2 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
2 &amp; 4 &amp; 4 &amp; 2\\
1 &amp; 1 &amp; 3 &amp; 3\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
2 &amp; 0 &amp; -3 \\
0 &amp; 2 &amp; -2 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
2 &amp; 4 &amp; 4 &amp; 2\\
1 &amp; 1 &amp; 3 &amp; 3\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
\begin{bmatrix}
x_{1}&#39; &amp; x_{2}&#39; &amp; x_{3}&#39; &amp; x_{4}&#39;\\
y_{1}&#39; &amp; y_{2}&#39; &amp; y_{3}&#39; &amp; y_{4}&#39;\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 &amp; 5 &amp; 5 &amp; 1\\
0 &amp; 0 &amp; 4 &amp; 4\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
\end{align}
$$
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; Insert 2D plot with the 8 points&lt;/p&gt;

&lt;h3 id=&#34;how-to-rotate-around-a-specific-point&#34;&gt;How to rotate around a specific point&lt;/h3&gt;

&lt;p&gt;Now imagine you have an image in a view, the origin is not a the center of the
view, it is probably at the top-left corner (implementations may vary),
but you want to rotate the image at the center of the view.&lt;br /&gt;
This transformation is composed of the following sequence:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;move anchor point to origin: &lt;code&gt;$ \left( -t_{x}, -t_{y} \right) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rotate by &lt;code&gt;$ \theta $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move back anchor point: &lt;code&gt;$ \left( t_{x}, t_{y} \right) $&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Where &lt;code&gt;$t$&lt;/code&gt; is the anchor point of our rotation transformation.&lt;/p&gt;

&lt;p&gt;Our transformations are defined by the first translation matrix
&lt;code&gt;$ \mathbf{C} $&lt;/code&gt;, the rotation matrix &lt;code&gt;$ \mathbf{B} $&lt;/code&gt;, and the last
translation matrix &lt;code&gt;$ \mathbf{A} $&lt;/code&gt;.&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{C} =
\begin{bmatrix}
1 &amp; 0 &amp; -t_{x} \\
0 &amp; 1 &amp; -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\text{ , }
\mathbf{B} =
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; 0 \\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\text{ and }
\mathbf{A} =
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
&lt;/div&gt;

&lt;p&gt;The composition of these transformations gives us the following product:&lt;/p&gt;

&lt;div&gt;
$$
\begin{align}
\mathbf{A} . \mathbf{B} . \mathbf{C}
&amp;=
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; 0 \\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
1 &amp; 0 &amp; -t_{x} \\
0 &amp; 1 &amp; -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; \cos \left( \theta \right) . -t_{x} + \sin \left( \theta \right) . -t_{y} \\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; \sin \left( \theta \right) . -t_{x} + \cos \left( \theta \right) . -t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}\\
\mathbf{A} . \mathbf{B} . \mathbf{C}
&amp;=
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; \cos \left( \theta \right) . -t_{x} - \sin \left( \theta \right) . -t_{y} + t_{x} \\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; \sin \left( \theta \right) . -t_{x} + \cos \left( \theta \right) . -t_{y} + t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align}
$$
&lt;/div&gt;

&lt;p&gt;Suppose we have the following points representing a square:
&lt;code&gt;$
\begin{bmatrix}
x_{1} &amp;amp; x_{2} &amp;amp; x_{3} &amp;amp; x_{4}\\
y_{1} &amp;amp; y_{2} &amp;amp; y_{3} &amp;amp; y_{4}\\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{bmatrix}
\text{ = }
\begin{bmatrix}
2 &amp;amp; 4 &amp;amp; 4 &amp;amp; 2\\
1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 3\\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{bmatrix}
$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; Insert 2D plot with those 4 points&lt;/p&gt;

&lt;p&gt;And we want to apply a rotation of &lt;code&gt;$ \theta = 90Â° $&lt;/code&gt; focusing on its center.&lt;br /&gt;
The new coordinates will be:&lt;/p&gt;

&lt;div&gt;
$$
\begin{align}
\begin{bmatrix}
x_{1}&#39; &amp; x_{2}&#39; &amp; x_{3}&#39; &amp; x_{4}&#39;\\
y_{1}&#39; &amp; y_{2}&#39; &amp; y_{3}&#39; &amp; y_{4}&#39;\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
&amp;=
\begin{bmatrix}
\cos \left( \theta \right) &amp; -\sin \left( \theta \right) &amp; \cos \left( \theta \right) . -t_{x} - \sin \left( \theta \right) . -t_{y} + t_{x} \\
\sin \left( \theta \right) &amp; \cos \left( \theta \right) &amp; \sin \left( \theta \right) . -t_{x} + \cos \left( \theta \right) . -t_{y} + t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
x_{1} &amp; x_{2} &amp; x_{3} &amp; x_{4}\\
y_{1} &amp; y_{2} &amp; y_{3} &amp; y_{4}\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
0 &amp; -1 &amp; 0 . \left(-3\right) - 1 . \left(-2\right) + 3 \\
1 &amp; 0 &amp; 1 . \left(-3\right) + 0 . \left(-2\right) + 2 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
2 &amp; 4 &amp; 4 &amp; 2\\
1 &amp; 1 &amp; 3 &amp; 3\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
0 &amp; -1 &amp; 5 \\
1 &amp; 0 &amp; -1 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
2 &amp; 4 &amp; 4 &amp; 2\\
1 &amp; 1 &amp; 3 &amp; 3\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}\\
\begin{bmatrix}
x_{1}&#39; &amp; x_{2}&#39; &amp; x_{3}&#39; &amp; x_{4}&#39;\\
y_{1}&#39; &amp; y_{2}&#39; &amp; y_{3}&#39; &amp; y_{4}&#39;\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
&amp;=
\begin{bmatrix}
4 &amp; 4 &amp; 2 &amp; 2\\
1 &amp; 3 &amp; 3 &amp; 1\\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
\end{align}
$$
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; Insert 2D plot with those 8 points&lt;/p&gt;

&lt;hr /&gt;


&lt;figure  &gt;
    
        &lt;img src=&#34;http://www.arnaudbos.com/img/matrices-java-and-android/koalifications.jpg&#34; alt=&#34;Koala meme&#34;
            
            /&gt;
    
    
&lt;/figure&gt;



&lt;hr /&gt;

&lt;h2 id=&#34;affine-transformations-with-java&#34;&gt;Affine transformations with Java&lt;/h2&gt;

&lt;p&gt;When I was working on the project I mentioned at the beginning of this article,
I was constantly moving back and forth between the
&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/awt/geom/AffineTransform.html&#34;&gt;JDK&amp;rsquo;s implementation of affine transformations&lt;/a&gt; and the
&lt;a href=&#34;https://developer.android.com/reference/android/graphics/Matrix.html&#34;&gt;Android SDK&amp;rsquo;s implementation of matrices&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I find the &lt;code&gt;java.awt.geom.AffineTransform&lt;/code&gt; class fairly well featured
but not that much, plus it is a bit ambiguous. Fortunately, the documentation is
good, it&amp;rsquo;s not perfect but at least it&amp;rsquo;s better than Android&amp;rsquo;s one on this
topic as we shall see later.&lt;/p&gt;

&lt;p&gt;The Javadoc starts with a reminder of what are 2D affine transformations and a
matrix multiplication pattern to transform coordinates.&lt;/p&gt;

&lt;div&gt;
$$
\begin{bmatrix}
x&#39;\\
y&#39;\\
1
\end{bmatrix}
=
\begin{bmatrix}
m00 &amp; m01 &amp; m02\\
m10 &amp; m11 &amp; m12\\
0 &amp; 0 &amp; 1
\end{bmatrix}
.
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}
=
\begin{bmatrix}
m00 . x + m01 . y + m02\\
m10 . x + m11 . y + m12\\
1
\end{bmatrix}
$$
&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s neat, you have to appreciate the effort there (I mean, is your
Javadoc that great? ðŸ˜‡ ), and Android&amp;rsquo;s Javadoc doesn&amp;rsquo;t have it so&amp;hellip;&lt;/p&gt;

&lt;p&gt;The way this pattern is written lets us see a glimpse of implementation details,
right? Those &lt;code&gt;m00&lt;/code&gt;, &lt;code&gt;m01&lt;/code&gt; and etc, they (not so) strangely resemble stringified
versions of indexes in a two-dimensional array.&lt;/p&gt;

&lt;h3 id=&#34;ambiguous-part-1&#34;&gt;Ambiguous â€” Part 1&lt;/h3&gt;

&lt;p&gt;So what is &lt;em&gt;&amp;ldquo;ambiguous&amp;rdquo;&lt;/em&gt; with this class? Granted it might be a matter of taste,
but if you look at the constructor
&lt;code&gt;AffineTransform(m00, m10, m01, m11, m02, m12)&lt;/code&gt; and the method
&lt;code&gt;setTransform(m00, m10, m01, m11, m02, m12)&lt;/code&gt;, they only take 6 input
parameters.&lt;/p&gt;

&lt;p&gt;While it makes perfectly sense to not take as inputs parameters that are fixed
(&lt;code&gt;0, 0, 1&lt;/code&gt;) in the context of 2D affine transformations, I find it disturbing.&lt;/p&gt;

&lt;p&gt;More disturbing perhaps, is the ordering of those parameters.&lt;/p&gt;

&lt;p&gt;If you make the parallel between those and our &lt;code&gt;$a$&lt;/code&gt;, &lt;code&gt;$b$&lt;/code&gt;, etc. to the &lt;code&gt;$i$&lt;/code&gt;
values we saw in the matrices above, you notice that the reading direction is not the
same.&lt;br /&gt;
With &lt;code&gt;$a$&lt;/code&gt;, &lt;code&gt;$b$&lt;/code&gt;, etc., we used to read more &lt;em&gt;&amp;ldquo;naturally&amp;rdquo;&lt;/em&gt; I would say, like
normal english written text: line by line.&lt;br /&gt;
Whereas &lt;code&gt;$m00$&lt;/code&gt;, &lt;code&gt;$m10$&lt;/code&gt;, etc. is reading the matrix column by column.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not saying one is better than the other, just that I&amp;rsquo;m more familiar with
the first one, and that it&amp;rsquo;s worth pointing at it to clarify the use of this
class. Because the &lt;code&gt;getMatrix(flatmatrix)&lt;/code&gt; method will fill in an
array containing the entries of the matrix in that specific order.&lt;br /&gt;
Also, &lt;code&gt;getMatrix&lt;/code&gt; &lt;em&gt;&amp;ldquo;Retrieves the 6 specifiable values in the 3x3 affine
transformation matrix&amp;rdquo;&lt;/em&gt;, which means it will only give you those &lt;code&gt;$m00$&lt;/code&gt;,
&lt;code&gt;$m10$&lt;/code&gt;, etc., entries, not the ones from the third row.&lt;/p&gt;

&lt;h3 id=&#34;well-featured-but-not-that-much&#34;&gt;Well featured but not that much&lt;/h3&gt;

&lt;p&gt;To understand what I mean, let&amp;rsquo;s try to execute the kind of transformations we
have seen throughout the first part of this article.&lt;/p&gt;

&lt;h5 id=&#34;1-can-we-translate&#34;&gt;1. Can we translate?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;translate(tx, ty)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a translation transformation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We&amp;rsquo;ll see what &amp;ldquo;concatenates&amp;rdquo; means in this context in a moment, for now what
we understand is that we have a method to apply a translation transformation.&lt;/p&gt;

&lt;h5 id=&#34;2-can-we-shear&#34;&gt;2. Can we shear?&lt;/h5&gt;

&lt;p&gt;Yes, but only by constants, not by angles, we have &lt;code&gt;shear(shx, shy)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a shearing transformation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;3-can-we-scale&#34;&gt;3. Can we scale?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;scale(sx, sy)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a scaling transformation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;4-can-we-reflect&#34;&gt;4. Can we reflect?&lt;/h5&gt;

&lt;p&gt;Not directly, at least I don&amp;rsquo;t see anything doing a reflexion directly, so we
either have to scale by negative values, or to use
&lt;code&gt;setTransform(-1, 0, 0, -1, 0, 0)&lt;/code&gt; (for example) manually and then
&lt;code&gt;concatenate&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;5-can-we-rotate&#34;&gt;5. Can we rotate?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;rotate(theta)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a rotation transformation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Beware: &lt;code&gt;theta&lt;/code&gt; here is in radians, not in degrees.&lt;/p&gt;

&lt;h5 id=&#34;6-can-we-scale-on-an-anchor-point&#34;&gt;6. Can we scale on an anchor point?&lt;/h5&gt;

&lt;p&gt;No. You will have to compose your transformation as we&amp;rsquo;ve done it &amp;ldquo;by hand&amp;rdquo;
above, with a combination of &lt;code&gt;scale(sx, sy)&lt;/code&gt; and &lt;code&gt;translate(tx, ty)&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;7-can-we-rotate-around-an-anchor-point&#34;&gt;7. Can we rotate around an anchor point?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;rotate(theta, anchorx, anchory)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a transform that rotates coordinates around
an anchor point.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;8-can-we-transform-points&#34;&gt;8. Can we transform points?&lt;/h5&gt;

&lt;p&gt;Yes! We have several methods available in order to transform points (even
shapes) from their original position to their new coordinates after the
transformation has been applied.&lt;/p&gt;

&lt;h5 id=&#34;why-am-i-not-happy-with-this&#34;&gt;Why am I not happy with this?&lt;/h5&gt;

&lt;p&gt;I am, actually, and there are more methods that allow you to do interesting
stuff with this class.&lt;br /&gt;
I&amp;rsquo;m just wondering why they decided to implement
&lt;code&gt;rotate(theta, anchorx, anchory)&lt;/code&gt; but not
&lt;code&gt;scale(sx, sy, anchorx, anchory)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the other hand, all the methods I&amp;rsquo;ve outlined above are quite opinionated.
Why? Because they assume that what you want to do is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates this transform with a transformation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An that&amp;rsquo;s where bad stuff happen.&lt;/p&gt;

&lt;h3 id=&#34;ambiguous-part-2&#34;&gt;Ambiguous â€” Part 2&lt;/h3&gt;

&lt;p&gt;All the transformations we&amp;rsquo;ve seen in the first part of this article are
defined this way:&lt;/p&gt;

&lt;div&gt;
$$
P&#39; = \mathbf{T}.P
$$
&lt;/div&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$P$&lt;/code&gt; is a point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$P&#39;$&lt;/code&gt; is the point where &lt;code&gt;$P$&lt;/code&gt; will land after the transformation has been applied&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\mathbf{T}$&lt;/code&gt; is a transformation matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\mathbf{T}$&lt;/code&gt; is the product of many transformations matrices, applied
in the reverse order: that is for transforming by &lt;code&gt;$\mathbf{A}$&lt;/code&gt;, then
&lt;code&gt;$\mathbf{B}$&lt;/code&gt;, then &lt;code&gt;$\mathbf{C}$&lt;/code&gt; we have
&lt;code&gt;$\mathbf{T} = \mathbf{C} . \mathbf{B} . \mathbf{A} $&lt;/code&gt;, and reciprocally.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, look at the definition of the description of the
&lt;code&gt;concatenate(AffineTransform Tx)&lt;/code&gt; method:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Concatenates an AffineTransform Tx to this AffineTransform Cx in the most commonly useful way to provide a new user space that is mapped to the former user space by Tx. Cx is updated to perform the combined transformation. Transforming a point p by the updated transform Cx&amp;rsquo; is equivalent to first transforming p by Tx and then transforming the result by the original transform Cx like this: Cx&amp;rsquo;(p) = Cx(Tx(p)) In matrix notation, if this transform Cx is represented by the matrix &lt;strong&gt;[this&lt;/strong&gt;] and Tx is represented by the matrix &lt;strong&gt;[Tx&lt;/strong&gt;] then this method does the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[this&lt;/strong&gt;] = &lt;strong&gt;[this&lt;/strong&gt;] x &lt;strong&gt;[Tx&lt;/strong&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In our notation this gives that for transforming by &lt;code&gt;$\mathbf{A}$&lt;/code&gt;, then
&lt;code&gt;$\mathbf{B}$&lt;/code&gt;, then &lt;code&gt;$\mathbf{C}$&lt;/code&gt; we have:&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{this}
=
\left( \left( \mathbf{this} . \mathbf{A} \right) . \mathbf{B} \right) . \mathbf{C}\\
\Leftrightarrow
\mathbf{this} = \mathbf{this} . \mathbf{Tx}
\text{ where }
\mathbf{Tx} = \mathbf{A} . \mathbf{B} . \mathbf{C}
$$
&lt;/div&gt;

&lt;p&gt;This is very different than:&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{this} = \mathbf{Tx} . \mathbf{this}
\text{ where }
\mathbf{Tx} = \mathbf{A} . \mathbf{B} . \mathbf{C}
$$
&lt;/div&gt;

&lt;p&gt;As we&amp;rsquo;ve seen, matrix multiplication is non-commutative, so this will lead to
very different results than what you might expect!&lt;/p&gt;

&lt;p&gt;The good news: there&amp;rsquo;s a method &lt;code&gt;preConcatenate(AffineTransform Tx)&lt;/code&gt; that does
what we want:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[this&lt;/strong&gt;] = &lt;strong&gt;[Tx&lt;/strong&gt;] x &lt;strong&gt;[this&lt;/strong&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The bad news: you won&amp;rsquo;t be able to represent your transformations with the
built-in &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt; as is. Because they don&amp;rsquo;t behave the
way you think.&lt;br /&gt;
At least they don&amp;rsquo;t behave the way &lt;strong&gt;&lt;em&gt;I&lt;/em&gt;&lt;/strong&gt; think about transformations, which is
the one I&amp;rsquo;ve described in the matrices section above.&lt;/p&gt;

&lt;p&gt;Honestly, I don&amp;rsquo;t know what the Javadoc means by &lt;em&gt;&amp;ldquo;in the most commonly useful
way to provide a new user space&amp;rdquo;&lt;/em&gt;. I&amp;rsquo;m sure it makes sense for some, but I
don&amp;rsquo;t get it.&lt;/p&gt;

&lt;p&gt;So how do we use the &lt;code&gt;AffineTransform&lt;/code&gt; class to chain our transformations the
way we want?&lt;br /&gt;
Fortunately, the class provides us with a bunch of useful static methods that
return new matrices that are ready to use and can be combined by using the
&lt;code&gt;preConcatenate&lt;/code&gt; method:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AffineTransform.getTranslateInstance(tx, ty)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AffineTransform.getRotateInstance(theta)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AffineTransform.getScaleInstance(sx, sy)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AffineTransform.getShearInstance(shx, shy)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;zooming-example&#34;&gt;Zooming example&lt;/h3&gt;

&lt;p&gt;The 2x zoom at the center of the rectangle from our previous
example can be achieved in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.arnaudbos.java2d;
// imports stripped

public class AffineTransformZoomExample {
    // code stripped

    private static class ZoomCanvas extends JComponent {

        public void paint(Graphics g) {
            Graphics2D ourGraphics = (Graphics2D) g;

            // code stripped

            // Draw initial object
            ourGraphics.setColor(Color.black);
            ourGraphics.drawRect(100, 100, 100, 100);

            // Create matrix (set to identity by default)
            AffineTransform tx = new AffineTransform();

            // This is not the transformation you&#39;re looking for
            tx.translate(-150, -150);
            tx.scale(2, 2);
            tx.translate(150, 150);
            ourGraphics.setTransform(tx);
            ourGraphics.setColor(Color.red);
            ourGraphics.drawRect(100, 100, 100, 100);

            // Reset matrix to identity to clear previous transformations
            tx.setToIdentity();

            // Apply our transformations in order to zoom-in the square
            tx.preConcatenate(AffineTransform.getTranslateInstance(-150, -150));
            tx.preConcatenate(AffineTransform.getScaleInstance(2, 2));
            tx.preConcatenate(AffineTransform.getTranslateInstance(150, 150));
            ourGraphics.setTransform(tx);
            ourGraphics.setColor(Color.green);
            ourGraphics.drawRect(100, 100, 100, 100);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;


&lt;figure  &gt;
    
        &lt;img src=&#34;http://www.arnaudbos.com/img/matrices-java-and-android/java-zoom-at-center.png&#34; alt=&#34;Demo of Java 2D zooming&#34;
            width=&#34;100%&#34;
            /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h6&gt;&lt;em&gt;Demo of Java 2D zooming: in black the original square, in red the unexpected transformation and in green the desired transformation&lt;/em&gt;&lt;/h6&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h2 id=&#34;affine-transformations-with-android&#34;&gt;Affine transformations with Android&lt;/h2&gt;

&lt;p&gt;Unlike Oracle, Google&amp;rsquo;s &lt;code&gt;android.graphics.Matrix&lt;/code&gt; class assumes you already
know your way around matrices. There&amp;rsquo;s no reminders, no details about matrices,
no explanations.&lt;br /&gt;
Nonetheless, the API is good and well featured, as long as you understand a
few things.&lt;/p&gt;

&lt;h3 id=&#34;construction&#34;&gt;Construction&lt;/h3&gt;

&lt;p&gt;Unlike Java, Android provides ways of building matrices that seem more
explicit and straightforward to me.&lt;/p&gt;

&lt;p&gt;The first thing we see in the Javadoc is a bunch of constants that are used to
describe each entry in the matrix:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int MPERSP_0 = 6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MPERSP_1 = 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MPERSP_2 = 8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MSCALE_X = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MSCALE_Y = 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MSKEW_X = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MSKEW_Y = 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MTRANS_X = 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int MTRANS_Y = 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put this back ordered by their value and now look at:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setValues(values)&lt;/code&gt;: &lt;em&gt;&amp;ldquo;Copy 9 values from the array into the matrix.&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getValues(values)&lt;/code&gt;: &lt;em&gt;&amp;ldquo;Copy 9 values from the matrix into the array.&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we see here is, I think, a more explicit API than the Java one: you are
dealing with a 3x3 dimensions matrix, so you specify/retrieve the 9 entries
that this matrix is composed of.&lt;/p&gt;

&lt;p&gt;Granted Java&amp;rsquo;s &lt;code&gt;AffineTransform&lt;/code&gt; class is named this way for a reason, that
reason being you can only deal with &lt;strong&gt;affine transformations&lt;/strong&gt;. Whereas
Android&amp;rsquo;s &lt;code&gt;Matrix&lt;/code&gt; class can be used to represent projections by playing with
the &lt;code&gt;MPERSP_0&lt;/code&gt;, &lt;code&gt;MPERSP_1&lt;/code&gt; and &lt;code&gt;MPERSP_2&lt;/code&gt; entries (hence their names and the
&lt;code&gt;isAffine()&lt;/code&gt; method).&lt;/p&gt;

&lt;h3 id=&#34;well-featured&#34;&gt;Well featured&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s do it again.&lt;/p&gt;

&lt;h5 id=&#34;1-can-we-translate-1&#34;&gt;1. Can we translate?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;preTranslate(dx, dy)&lt;/code&gt; and &lt;code&gt;postTranslate(dx, dy)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre/Post-concats the matrix with the specified translation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;2-can-we-shear-1&#34;&gt;2. Can we shear?&lt;/h5&gt;

&lt;p&gt;Yes, but only by constants not by angles, and it&amp;rsquo;s named &amp;ldquo;skew&amp;rdquo;.&lt;br /&gt;
We have &lt;code&gt;preSkew(kx, ky)&lt;/code&gt; and  &lt;code&gt;postSkew(kx, ky)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre/Post-concats the matrix with the specified skew.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also have &lt;code&gt;preSkew(kx, ky, px, py)&lt;/code&gt; and &lt;code&gt;postSkew(kx, ky, px, py)&lt;/code&gt; in order
to skew not around the origin, by around a given anchor point. That&amp;rsquo;s nice.&lt;/p&gt;

&lt;h5 id=&#34;3-can-we-scale-1&#34;&gt;3. Can we scale?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;preScale(sx, sy)&lt;/code&gt; and &lt;code&gt;postScale(sx, sy)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre/Post-concats the matrix with the specified scale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;4-can-we-reflect-1&#34;&gt;4. Can we reflect?&lt;/h5&gt;

&lt;p&gt;Again, not directly, we can scale by negative values, or we can use
&lt;code&gt;setValues({-1, 0, 0, 0, -1, 0, 0, 0, 1})&lt;/code&gt; (for example) and then
&lt;code&gt;postConcat&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;5-can-we-rotate-1&#34;&gt;5. Can we rotate?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;preRotate(degrees)&lt;/code&gt; and &lt;code&gt;postRotate(degrees)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre/Post-concats the matrix with the specified rotation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;6-can-we-scale-on-an-anchor-point-1&#34;&gt;6. Can we scale on an anchor point?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;preScale(sx, sy, px, py)&lt;/code&gt; and &lt;code&gt;postScale(sx, sy, px, py)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre/Post-concats the matrix with the specified scale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;7-can-we-rotate-around-an-anchor-point-1&#34;&gt;7. Can we rotate around an anchor point?&lt;/h5&gt;

&lt;p&gt;Yes! We have &lt;code&gt;preRotate(degrees, px, py)&lt;/code&gt; and &lt;code&gt;postRotate(degrees, px, py)&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre-Post-concats the matrix with the specified rotation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;8-can-we-transform-points-1&#34;&gt;8. Can we transform points?&lt;/h5&gt;

&lt;p&gt;Also yes! We have several methods available in order to transform points and
shapes from their original position to their new coordinates after the
transformation has been applied.&lt;/p&gt;

&lt;h3 id=&#34;ambiguous&#34;&gt;Ambiguous&lt;/h3&gt;

&lt;p&gt;Yes, I like this word&amp;hellip;&lt;/p&gt;

&lt;p&gt;The API is undeniably well featured, provides &lt;code&gt;pre&lt;/code&gt; and &lt;code&gt;post&lt;/code&gt; methods for
the most common transformations, a &lt;code&gt;setValues&lt;/code&gt; method to create matrices of
any shape, and also &lt;code&gt;preConcat(Matrix other)&lt;/code&gt; and &lt;code&gt;postConcat(Matrix other)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What do they do?&lt;/p&gt;

&lt;h5 id=&#34;preconcat&#34;&gt;preConcat&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Preconcats the matrix with the specified matrix. M&amp;rsquo; = M * other&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, if I read correctly, this is equivalent to:&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{this} = \mathbf{this} . \mathbf{Tx}
$$
&lt;/div&gt;

&lt;p&gt;Wait&amp;hellip; in Java&amp;rsquo;s &lt;code&gt;AffineTransform&lt;/code&gt;, this was the equivalent of the
&lt;code&gt;concatenate&lt;/code&gt; method&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;postconcat&#34;&gt;postConcat&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Postconcats the matrix with the specified matrix. M&amp;rsquo; = other * M&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Again, if I read correctly, this is equivalent to:&lt;/p&gt;

&lt;div&gt;
$$
\mathbf{this} = \mathbf{Tx} . \mathbf{this}
$$
&lt;/div&gt;

&lt;p&gt;Wait&amp;hellip; in Java&amp;rsquo;s &lt;code&gt;AffineTransform&lt;/code&gt;, this was the equivalent of the
&lt;code&gt;preConcatenate&lt;/code&gt; method&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;wtf-dude&#34;&gt;WTF dude?&lt;/h5&gt;

&lt;p&gt;Exactly. If you don&amp;rsquo;t read the doc, &lt;strong&gt;you&amp;rsquo;re screwed&lt;/strong&gt; ðŸ’©&lt;/p&gt;

&lt;p&gt;So who&amp;rsquo;s right?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve searched a few minutes on the Interwebs and here&amp;rsquo;s what I&amp;rsquo;ve found
&lt;a href=&#34;https://en.wikipedia.org/wiki/Matrix_multiplication&#34;&gt;from Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;pre-multiply (or left multiply) &lt;code&gt;$\mathbf{A}$&lt;/code&gt; by &lt;code&gt;$\mathbf{B}$&lt;/code&gt;&amp;rdquo; means
&lt;code&gt;$\mathbf{B}.\mathbf{A}$&lt;/code&gt;,
while &amp;ldquo;post-multiply (or right multiply) &lt;code&gt;$\mathbf{A}$&lt;/code&gt; by &lt;code&gt;$\mathbf{C}$&lt;/code&gt;&amp;ldquo;
means &lt;code&gt;$\mathbf{A}.\mathbf{C}$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And because two sources are better than one, from
&lt;a href=&#34;http://web.cse.ohio-state.edu/~whmin/courses/cse5542-2013-spring/6-Transformation_II.pdf&#34;&gt;this &amp;ldquo;ohio-state&amp;rdquo; course&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pre-multiplication is to multiply the new matrix &lt;code&gt;$\mathbf{B}$&lt;/code&gt; to the left
of the existing matrix &lt;code&gt;$\mathbf{A}$&lt;/code&gt; to get the result
&lt;code&gt;$\mathbf{C} = \mathbf{B}.\mathbf{A}$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Post-multiplication is to multiply the new matrix &lt;code&gt;$\mathbf{B}$&lt;/code&gt; to the right
of the existing matrix &lt;code&gt;$\mathbf{A}$&lt;/code&gt; to get the result
&lt;code&gt;$\mathbf{C} = \mathbf{A}.\mathbf{B}$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So it seems like Sun/Oracle got it right, and Google got it backward. But it
doesn&amp;rsquo;t solve our problem: we have to be cautious when applying affine
transformations, because the order matters!&lt;/p&gt;

&lt;p&gt;And because of the way we want to apply our transformations, in Android we&amp;rsquo;re
going to make use of the &lt;code&gt;post&lt;/code&gt; methods. But the &lt;code&gt;pre&lt;/code&gt; methods are here also
and will simplify your like if you need this kind of operations.&lt;/p&gt;

&lt;h3 id=&#34;rotation-example&#34;&gt;Rotation example&lt;/h3&gt;

&lt;p&gt;The 90Â° rotation at the center of the rectangle from our previous
example can be achieved in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TODO insert code
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; insert screenshot of Android rotation here&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;TODO&lt;/code&gt; do it&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>