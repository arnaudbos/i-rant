<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
        
    <meta property="og:title" content="Loom - Part 2 - Blocking code" />
    <meta property="og:description" content="Part 2 on a series of articles about OpenJDK&#39;s Project Loom" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://i-rant.arnaudbos.com/loom-part-2-blocking/" />
    
    <meta property="og:image" content="https://i-rant.arnaudbos.com/img/loom/loom.jpg" />
    

    <meta name="description" content="My corner of teh interweb.">
    <link rel="shortcut icon" type="image/x-icon" href="https://i-rant.arnaudbos.com/img/favicon.ico">
    <title>Loom - Part 2 - Blocking code</title>
    <meta name="generator" content="Hugo 0.54.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Raleway|Fira+Code&display=swap">
    <link rel="stylesheet" type="text/css" href="https://i-rant.arnaudbos.com/css/main.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/darcula.min.css">
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://www.arnaudbos.com/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="https://i-rant.arnaudbos.com/">BLOG</a></li>
        
        <li><a href="https://side-effects.arnaudbos.com/">PROJECTS</a></li>
        
        <li><a href="https://talks.arnaudbos.com/">TALKS</a></li>
        
        <li><a href="https://level-up.arnaudbos.com/">LEVEL-UP</a></li>
        
        <li><a href="https://vitae.arnaudbos.com/">RESUME</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      <div class="container">
        <div class="blog-post">
          <h3>
            <a href="/loom-part-2-blocking/">Loom - Part 2 - Blocking code</a>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
          December 18, 2019
          &nbsp;&nbsp;
          —
          &nbsp;&nbsp;
          15 minutes read
          </h4>
        </div>
        <div>
          <h4>
            
            <span class="label label-success tag">java</span>
            
            <span class="label label-success tag">concurrency</span>
            
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              

<blockquote>
<p>Part 2 in a series of articles about Project Loom.<br />
In this part we implement a proxy service, the easiest way possible.</p>

<p>The companion code repository is at <a href="https://github.com/arnaudbos/untangled">arnaudbos/untangled</a></p>

<p>If you&rsquo;d like you could head over to<br />
<a href="../loom-part-0-rationale">Part 0 - Rationale</a><br />
<a href="../loom-part-1-scheduling">Part 1 - It&rsquo;s all about Scheduling</a><br />
<a href="../loom-part-2-blocking">Part 2 - Blocking code</a> (this page)<br />
<a href="../loom-part-3-async">Part 3 - Asynchronous code</a></p>
</blockquote>


<figure  style="text-align: center;">
    <a target="_blank" href="https://www.maxpixels.net/Post-Impressionist-Post-Impressionism-Fine-Art-Dutch-1428139">
        <img src="/img/loom/loom.jpg" alt="Loom"
            width="100%"
            />
    </a>
    
    <figcaption>
        <h6><em>Weaving</em></h6>
        <p>
        Max Pixel
        <a target="_blank" href="https://creativecommons.org/publicdomain/zero/1.0/deed.en"> 
            CC0 1.0
        </a> 
        </p> 
    </figcaption>
    
</figure>



<hr />

<h2 id="table-of-contents">Table Of Contents</h2><div id="toc" class="well col-md-12"><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#a-simple-use-case">A simple use case</a></li>
<li><a href="#first-implementation">First implementation</a></li>
<li><a href="#profiling">Profiling</a>
<ul>
<li><a href="#cpu-usage">CPU usage</a></li>
<li><a href="#threads">Threads</a></li>
</ul></li>
<li><a href="#context-switches">Context switches</a>
<ul>
<li><a href="#what-they-are">What they are</a></li>
<li><a href="#why-they-are-bad">Why they are bad</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</nav></div>

<h2 id="a-simple-use-case">A simple use case</h2>

<p>One of the biggest pain points I had learning about concurrent programming was the emphasis put on
<code>Blocking</code>, <code>Non-blocking</code>, <code>Synchronous</code> and <code>Asynchronous</code> code.<br />
We&rsquo;ll touch on all four in the next parts of this series.</p>

<p>After reading a lot I figured that implementing a simple use case would comfort my understandings and help me convey
what I wanted to explain. So here&rsquo;s a not totally made up, simple use case:</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/demo.png" itemprop="contentUrl" data-size="2530x1180">
      <img src="/img/loom/demo.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    Sequence diagram, also detailed in text in the following paragraphs.
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Use case: A proxy server</div>
</div>


<p>Clients need access to some restricted resources. A proxying service will rate-limit the clients access, based on a
token policy.</p>

<ol>
<li>A client addresses a download request to the proxy service.</li>
<li>The proxy service registers the request to a coordinator.</li>
<li>The coordinator is responsible for the scheduling logic using a priority queue. Its logic is irrelevant.</li>
<li>The coordinator responds either &ldquo;Unavailable&rdquo; or &ldquo;Available&rdquo;.</li>
<li>&ldquo;Unavailable&rdquo; means that the client can&rsquo;t download the resource just yet (responses&rsquo; payload contains a token).</li>
<li>The payload also contains an &ldquo;ETA&rdquo; so the service can decide to abort or to retry, using the token to keep its place
in the coordinator&rsquo;s queue.</li>
<li>The payload also contains a &ldquo;wait&rdquo; time to rate-limit the retry requests to the coordinator.</li>
<li>The proxy may have to retry a couple of times, on behalf of the client, but will eventually receive an &ldquo;Available&rdquo;
response.</li>
<li>With an &ldquo;Available&rdquo; response and the token contained in its payload, the proxy service can initiate a download
request to the data source.</li>
<li>The proxy service streams the content of the download request back to its client;</li>
<li>While at the same time sending periodic &ldquo;heartbeat&rdquo; requests to the coordinator to ensure its token is not revoked.</li>
</ol>

<p>We are going to use this scenario in the next parts of the series. We will implement this proxy service in
various ways, simulate a few (200) clients connecting simultaneously and see the pros and cons of each implementation.</p>

<blockquote>
<p>Bear in mind that this is not a benchmark, it&rsquo;s just an experiment.<br />
200 clients is a really low number but is enough to observe a few interesting things.</p>
</blockquote>

<h2 id="first-implementation">First implementation</h2>

<p>I am now going to show you the easiest way I came up with to implement this proxy service.</p>

<p>You can find the complete source code for this sample <a href="https://github.com/arnaudbos/untangled/blob/master/hawaii/src/main/java/io/monkeypatch/untangled/Chapter01_SyncBlocking.java">here</a>.</p>

<p><code>getThingy()</code> is the download endpoint in this example. Each client &ldquo;connecting&rdquo; to the proxy hits this method:</p>

<pre><code class="language-java">private void getThingy() throws EtaExceededException, IOException {
    println(&quot;Start getThingy.&quot;);

    try {
①      Connection.Available conn = getConnection();
        println(&quot;Got token, &quot; + conn.getToken());

        Thread pulse = makePulse(conn);
②      try (InputStream content = gateway.downloadThingy()) {
③         pulse.start();

④          ignoreContent(content);
        } catch (IOException e) {
            err(&quot;Download failed.&quot;);
            throw e;
        }
        finally {
⑤          pulse.interrupt();
        }
    } catch (InterruptedException e) {
        // D'oh!
        err(&quot;Task interrupted.&quot;);
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
    }
    println(&quot;Download finished&quot;)
}
</code></pre>

<ol>
<li>We retrieve an &ldquo;Available&rdquo; connection <code>conn</code> from the coordinator</li>
<li>We initiate the download request to the data source (called <code>gateway</code> in this example).</li>
<li>Once the download has begun we start the heartbeat requests (<em>pulse</em> thread).</li>
<li>While at the same time consuming the content (<code>InputStream</code>, here we simply drop it, but in a real scenario we
would forward to the client).<br /></li>
<li>Once the download ends (successfully or not) we stop sending heartbeat requests and the call ends.</li>
</ol>

<p>Maybe you were hoping to see some kind of framework here, some <em>@Controller</em> or <em>@GET</em> annotation perhaps?</p>

<p>In this series, I&rsquo;m not going to bother with a framework. Because the number of clients is so small and this is not a
benchmark, I am just simulating the client calls from within the same JVM.</p>

<p>This way, I am able to use the kind of <code>ExecutorService</code> I want for each implementation, in order to outline a few
things. This executor and its thread pool will simulate the Web Server thread pool that could be found inside any Web
Framework. In the end it is more illustrative to have it directly at hand.</p>

<p>Let&rsquo;s simulate a few clients, shall we?</p>

<pre><code class="language-java">CompletableFuture&lt;Void&gt;[] futures = new CompletableFuture[MAX_CLIENTS];
for(int i=0; i&lt;MAX_CLIENTS; i++) {
    int finalI = i;
    futures[i] = new CompletableFuture&lt;&gt;();
    elasticServiceExecutor.submit(() -&gt; {
        try {
            getThingy(finalI);
            futures[finalI].complete(null);
        } catch (EtaExceededException e) {
            err(&quot;Couldn't getThingy because ETA exceeded: &quot; + e);
            futures[finalI].completeExceptionally(e);
        } catch (Exception e) {
            err(&quot;Couldn't getThingy because something failed: &quot; + e);
            futures[finalI].completeExceptionally(e);
        }
    });
}
</code></pre>

<p>In this implementation, <code>elasticServiceExecutor</code> is a &ldquo;cached&rdquo; <code>ThreadPoolExecutor</code>, and I will explain why in a
little bit.</p>

<pre><code class="language-java">elasticServiceExecutor =
    Executors.newCachedThreadPool(new PrefixedThreadFactory(&quot;service&quot;));
</code></pre>

<p>We have a &ldquo;Web Server&rdquo;, clients and our download controller.</p>

<p>There are a few things to unpack from this controller.<br />
Let&rsquo;s start with the least interesting bit first, <code>makePulse</code>:</p>

<pre><code class="language-java">private Thread makePulse(Connection.Available conn) {
    return new Thread(() -&gt; {
        while(!Thread.currentThread().isInterrupted()) {
            try {
                // Periodic heartbeat
                Thread.sleep(2_000L);

                println(&quot;Pulse!&quot;);
                coordinator.heartbeat(conn.getToken());
            } catch (InterruptedException e) {
                // D'oh!
                Thread.currentThread().interrupt();
            }
        }
    });
}
</code></pre>

<p>Nothing fancy here: sleep for a while, send a request, sleep for a while, send a request, &hellip;</p>

<p>You may have noticed that <em>getThingy</em> uses the <code>gateway</code> service to talk to the data source and that <em>makePulse</em> uses
the <code>coordinator</code> service to talk to the coordinator.<br />
So what is this <code>getConnection</code> method and why does <em>getThingy</em> not use <code>coordinator</code> directly?</p>

<p>Because of the retry logic we&rsquo;ve talked about before!<br />
<code>getConnection</code> is actually a helper to handle
the <em>Unavailable</em> responses from the coordinator and only return when an <em>Available</em> response has been received. Here&rsquo;s
the code:</p>

<pre><code class="language-java">private Connection.Available getConnection()
    throws EtaExceededException, InterruptedException
{
①  return getConnection(0, 0, null);
}

private Connection.Available getConnection(long eta, long wait, String token)
    throws EtaExceededException, InterruptedException
{
    for(;;) {
        if (eta &gt; MAX_ETA_MS) {
            throw new EtaExceededException();
        }

        if (wait &gt; 0) {
            Thread.sleep(wait);
        }

        println(&quot;Retrying download after &quot; + wait + &quot;ms wait.&quot;);
    
②      Connection c = coordinator.requestConnection(token);
        if (c instanceof Connection.Available) {
④          return (Connection.Available) c;
        }
③      Connection.Unavailable unavail = (Connection.Unavailable) c;
        eta = unavail.getEta();
        wait = unavail.getWait();
        token = unavail.getToken();
    }
}
</code></pre>

<ol>
<li>We start with initial <code>eta</code> and <code>wait</code> times at zero and no token (<code>null</code>).</li>
<li>We try to get a grant from the coordinator.</li>
<li>If the coordinator rejects us with an <code>Unavailable</code> response, we update the <em>eta</em>, <em>wait</em> and <em>token</em> and loop;</li>
<li>Otherwise we can return the <code>Available</code> response.</li>
</ol>

<p>As I said: the <strong>easiest</strong> implementation I could come up with.</p>

<p><strong>Any Java developer from junior to expert can understand this code!</strong><br />
It is <em>classic</em>, <em>old</em>, <em>boring</em>, <em>imperative</em> Java code which <strong><em>does the job</em></strong>.</p>

<p>And <em>easy</em> is important, right? I&rsquo;m 100% confident that all of you know what the service does and how it does it. We
can now build from here with all the subsequent implementations, using different paradigms and APIs.</p>

<p>Before that, let&rsquo;s now see what this code <em>actually</em> does.</p>

<h2 id="profiling">Profiling</h2>

<p>The first tool I turned to is <a href="https://visualvm.github.io/">VisualVM</a>. In the absence of metrics from the code, defaulting to VisualVM gives a basic
understanding of the behaviour of a JVM application regarding its thread and objects allocation, CPU utilization, GC
pressure, etc.</p>

<h3 id="cpu-usage">CPU usage</h3>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/impl1-cpu.png" itemprop="contentUrl" data-size="3124x1730">
      <img src="/img/loom/impl1-cpu.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">CPU utilization is low</div>
</div>


<p>CPU usage is really limited in this example (at a guess, I&rsquo;d say the 95 percentile is less than 3% with an outlier at
about 8% for a very short time during startup). Which makes sense, right?</p>

<p>Indeed, this use case is designed to be <em>I/O bound</em>: it&rsquo;s not like we&rsquo;re computing any math. Instead
we send a bunch or requests, wait a little in between, then some more requests to forward content from
buffers and&hellip; Done.</p>

<p>None of this requires a lot of CPU power so this screenshot should not be surprising. In fact, it will be the same
for all the other implementations we will see in the next parts so I am not going to embed it again.</p>

<p>Looking at the threads is much more interesting.</p>

<h3 id="threads">Threads</h3>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/impl1-threads.png" itemprop="contentUrl" data-size="3110x1830">
      <img src="/img/loom/impl1-threads.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">We&#39;re creating a lot of threads</div>
</div>


<p>We can see in the figure above that when the application starts, meaning &ldquo;when our clients connect&rdquo;, it is going to
create a first batch of about 200 threads. And then progressively start 200 more over a period of about 5 seconds.</p>

<p>The last 200 are pretty obvious given the implementation of <code>makePulse</code>: once the proxy begins to receive <code>Available</code>
responses from the coordinator, it starts the threads instantiated by the calls to <code>makePulse</code>. This is just an
implementation detail. A wrong one for sure, but a minor detail.</p>

<p>What should be more intriguing are the first 200 (the 10 additional ones are created by the JVM itself, the net
addition from our application is of 200). Why are 200 clients creating 200 threads?</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/impl1-threads-running.png" itemprop="contentUrl" data-size="2820x1786">
      <img src="/img/loom/impl1-threads-running.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">200&#43; threads &#34;running&#34;</div>
</div>


<p>They all seem pretty busy (green means &ldquo;running&rdquo; in VisualVM), which is weird. We&rsquo;ve seen that CPU usage is really low,
so our cores don&rsquo;t actually do much in practice!</p>

<p>We must take a closer look at what those threads actually do. Let&rsquo;s get a <em>thread dump</em>.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/impl1-thread-dump.png" itemprop="contentUrl" data-size="2898x976">
      <img src="/img/loom/impl1-thread-dump.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Typical thread from this application</div>
</div>


<p>This screenshot shows only one of the many threads described in the thread dump because they all look alike.</p>

<p>The typical thread in this application seems to be running this <code>SocketDispatch#read0</code> native method. And they aren&rsquo;t
&ldquo;just&rdquo; running this method but in fact spending <strong>most of their time</strong> running it.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/impl1-flame.png" itemprop="contentUrl" data-size="2158x1548">
      <img src="/img/loom/impl1-flame.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Flame Graph</div>
</div>


<p>This <a href="http://www.brendangregg.com/flamegraphs.html">flame graph</a> was acquired using <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> and shows that time spent running <code>SocketDispatcher#read0</code>&rsquo;s
underlying <code>read</code> system call dominates our application.</p>

<p>If we track its call stack to find its origin, we stumble upon <code>lambda$run$1</code>. Which, in fact, is the call to the
astutely named <code>blockingRequest</code> method inside of the <em>gateway</em> service:</p>

<pre><code class="language-java">class SyncGatewayService {
    InputStream downloadThingy() throws IOException {
        return blockingRequest(
            &quot;http://localhost:7000&quot;,
            String.format(HEADERS_TEMPLATE,
                          &quot;GET&quot;,
                          &quot;download&quot;,
                          &quot;text/*&quot;,
                          String.valueOf(0))
        );
    }
}
</code></pre>

<p>Without further suspense, here&rsquo;s its code:</p>

<pre><code class="language-java">public static InputStream blockingRequest(String url, String headers)
    throws IOException
{
    println(&quot;Starting request to &quot; + url);
    URL uri = new URL(url);
    SocketAddress serverAddress =
        new InetSocketAddress(uri.getHost(), uri.getPort());
    SocketChannel channel = SocketChannel.open(serverAddress);
    ByteBuffer buffer = ByteBuffer.wrap(
        (headers + &quot;Host: &quot; + uri.getHost() + &quot;\r\n\r\n&quot;).getBytes()
    );
    do {
        channel.write(buffer);
    } while(buffer.hasRemaining());

    return channel.socket().getInputStream();
}
</code></pre>

<p>You can see in the call chain that <code>read0</code> originates from calling <code>InputStream#read</code>. The <em>InputStream</em> itself is
obtained from the <code>SocketChannel</code>. And this, dear reader, is the ugly detail that makes this application not
efficient and is the reason why we end up with as many threads as clients.</p>

<p>Because this socket channel (analogous to a <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>) is written to and read from in <strong>blocking mode</strong>.</p>

<h2 id="context-switches">Context switches</h2>

<h3 id="what-they-are">What they are</h3>

<p>What&rsquo;s a blocking call and why is it bad? Let&rsquo;s talk about what happens when one of our threads encounters a thread
blocking call.</p>

<p>For the sake of simplicity, I am going to assume here that our CPUs run two kinds of instructions.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/engine.png" itemprop="contentUrl" data-size="1928x770">
      <img src="/img/loom/engine.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Legend</div>
</div>


<p>Instructions coming from what we&rsquo;ll call our &ldquo;user code&rdquo; represented by the triangle, hexagon, square and round shapes.<br />
And instructions coming from the kernel whose goals are to enforce scheduling policies represented by the circle and
cross shapes.<br />
The CPU will be represented by a <a href="https://en.wikipedia.org/wiki/Wankel_engine">Wankel engine</a>.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-1.png" itemprop="contentUrl" data-size="3080x1046">
      <img src="/img/loom/context-switch-1.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Kernel threads</div>
</div>


<p>On the JVM, the threads we manipulate are actually kernel threads. The threads which are instantiated and managed by
the various flavors of <code>ExecutorService</code> available via the helper <code>java.util.concurrent.Executors</code> are an abstraction
over native threads with additional thread pool logic, tasks queues management and scheduling mechanisms.</p>

<p>As said earlier, the executor I&rsquo;ve used in this implementation is a &ldquo;cached&rdquo; <code>ThreadPoolExecutor</code>.</p>

<pre><code class="language-java">elasticServiceExecutor =
    Executors.newCachedThreadPool(new PrefixedThreadFactory(&quot;service&quot;));
</code></pre>

<p>This executor handles an initial pool of threads as well as a task queue (<code>SynchronousQueue</code>).<br />
It also has a reference to a <code>ThreadFactory</code>, because this executor will try to match each <code>Runnable</code> that is submitted
to it via its <code>submit</code> method to a runnable thread in its pool. If no thread is available to run the next <em>Runnable</em> in
the queue, it will use the <em>ThreadFactory</em> to create a new thread and hand the <em>Runnable</em> object to it.</p>

<p>The threads thus created are managed by the kernel, which itself manages its own priority queue and acts according to
its scheduling policy (we&rsquo;ve talked about this in the <a href="../loom-part-1-scheduling">part 1 of this series</a>). The priority queue shown in the
illustration above is the kernel&rsquo;s.</p>

<p>So, in a nutshell, when a thread is scheduled to run, its instructions are executed one after the other by the CPU.<br />
Up until it finishes or a blocking call is made.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-2.png" itemprop="contentUrl" data-size="3038x1014">
      <img src="/img/loom/context-switch-2.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">Close Encounters of the Blocking Kind</div>
</div>


<p>In the illustration above, the &ldquo;round&rdquo; instructions come from the currently scheduled thread. We can see that the
current instruction is in fact a blocking OS call (syscall, such as <code>read</code>).</p>

<p>What will actually happen here, is a <strong>context switch</strong>.<br />
Because the thread is currently trying to execute an action <em>outside</em> its current <a href="https://en.wikipedia.org/wiki/Protection_ring">protection ring</a>.</p>

<p>JVM applications run in <em>user space</em> (ring 3) to ensure memory and hardware protection.<br />
The kernel runs in <em>kernel space</em> (ring 0) and is responsible to ensure computer security and that processes behave,
basically.</p>

<p>When executing syscalls such as blocking <code>read</code>s, <em>kernel space</em> access level is required. Kernel instructions will be
run on behalf of the &ldquo;user code&rdquo; and will, for instance, ensure that this thread does not hold onto the CPU while
waiting for its call to return and that another thread has a chance to run in the mean time, hence ensuring compliance
with the scheduling policies.</p>

<p>For the sake of simplicity, I&rsquo;m representing a context switch as a 2 step process.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-3.png" itemprop="contentUrl" data-size="3016x1036">
      <img src="/img/loom/context-switch-3.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">A context switch</div>
</div>


<p>During the first step, the kernel is going to <em>suspend</em> the execution of the current thread. In order to do this,
it is going to save a few things such as the current instruction or process counter (on which instruction did the
thread pause), the thread&rsquo;s current call stack, the state of CPU registers it was accessing, etc.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-4.png" itemprop="contentUrl" data-size="2990x1024">
      <img src="/img/loom/context-switch-4.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">1/2: save execution state</div>
</div>


<p>The kernel is going to save all this in a data structure (see <a href="https://www.tutorialspoint.com/what-is-process-control-block-pcb">PCB</a>, for Process Control Block), and put the thread
back into the priority queue.</p>

<blockquote>
<p>Also for the sake of simplicity, I am representing the &ldquo;not ready&rdquo; state of a thread as if flagged and put back into
a priority queue. But the actual logic may be more complicated, including several distinct queues for different
&ldquo;waiting&rdquo; purposes or any arbitrary logic as kernel developers see fit.</p>
</blockquote>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-5.png" itemprop="contentUrl" data-size="2996x1014">
      <img src="/img/loom/context-switch-5.png" itemprop="thumbnail"
        
        
        width="100%"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>


<div class="title">2/2: schedule next</div>
</div>


<p>In the second step, the kernel decides which thread should be scheduled next according to its policies, and this thread
is allocated to the CPU. If this thread had been scheduled before, its state would have to be restored first, of
course.</p>

<p>This thread itself may contain instructions pointing at a blocking syscall, which would trigger a new context switch,
and so on and so forth until eventually the result of the blocking syscall made by the round instruction above is
available and this thread is scheduled again.</p>

<div class="gallery" itemscope itemtype="http://schema.org/ImageGallery">

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-6.png" itemprop="contentUrl" data-size="3036x1052">
      <img src="/img/loom/context-switch-6.png" itemprop="thumbnail"
        
        
        width="395px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-7.png" itemprop="contentUrl" data-size="3014x1002">
      <img src="/img/loom/context-switch-7.png" itemprop="thumbnail"
        
        
        width="395px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-8.png" itemprop="contentUrl" data-size="3046x1016">
      <img src="/img/loom/context-switch-8.png" itemprop="thumbnail"
        
        
        width="396px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>

  <figure itemscope itemtype="http://schema.org/ImageObject">
  <a href="/img/loom/context-switch-9.png" itemprop="contentUrl" data-size="3066x1034">
      <img src="/img/loom/context-switch-9.png" itemprop="thumbnail"
        
        
        width="390px"
        height="142"
        />
  </a>

  <figcaption itemprop="caption description">
    
    <span itemprop="copyrightHolder"></span>
  </figcaption>
</figure>



</div>


<p>Now it&rsquo;s time to connect the dots and understand why blocking calls deserve such hatred.</p>

<h3 id="why-they-are-bad">Why they are bad</h3>

<p>One of the blog posts I like the most to explain this issue is
<em>&ldquo;Little&rsquo;s Law, Scalability and Fault Tolerance: The OS is your bottleneck (and what you can do about it)&rdquo;</em> by
<a href="https://twitter.com/pressron" title="pressron" target="_blank">@pressron</a>.</p>


<figure  style="text-align: center;">
    <a target="_blank" href="https://blog.paralleluniverse.co/2014/02/04/littles-law/">
        <img src="/img/loom/little.png" alt="Little&#39;s Law, Scalability and Fault Tolerance: The OS is your bottleneck (and what you can do about it)"
            width="100%"
            />
    </a>
    
</figure>



<p>I&rsquo;m trying to do half as good in this series, so I strongly suggest that you take a look at it and read <em>at least</em> the
first 3 parts of the article: <em>&ldquo;Our Little Service&rdquo;</em>, <em>&ldquo;Little’s Law&rdquo;</em> and <em>&ldquo;What Dominates the Capacity&rdquo;</em>.</p>

<p>It explains that the number of connections our services can handle when executing blocking code is
not limited by the number of network connections our OS can keep open, but by the number of threads we create.<br />
Each kernel thread stack takes memory space and thread scheduling (context switches explained above) wastes CPU cycles,
induce CPU cache misses and adds latency to requests.</p>

<blockquote>
<p>Allowing the software to spawn thread willy-nilly may bring our application to its knees, so we usually set a hard
limit on the number of threads we let the application spawn.<br />
— R. Pressler</p>
</blockquote>

<p>So we know that we can&rsquo;t let the number of threads grow too much.<br />
But why is this code creating one thread-per-connection (not to mention the additional &ldquo;pulsing&rdquo; thread)?</p>

<p>The answer is: because of the cached <code>ThreadPoolExecutor</code>!<br />
As I said:</p>

<blockquote>
<p>If no thread is available to run the next <em>Runnable</em> in the queue, it will use the <em>ThreadFactory</em> to create a new
thread and hand the <em>Runnable</em> object to it.</p>
</blockquote>

<p>In this implementation, each request issues blocking writes and reads to and from the <code>SocketChannel</code>.<br />
Each of these calls lead to context switches during which the current thread will be paused.<br />
So connection requests added to the <code>ThreadPoolExecutor</code> waiting queue will quickly drain the number of threads
cached in the pool, because they are paused!<br />
This triggers the creation of more threads by the executor and <span class="emoji">:boom:</span>
</p>

<p>We could use a different executor, such as <code>Executors.newFixedThreadPool(int, ThreadFactory)</code> in order to <em>&ldquo;limit the
number of threads we let the application spawn&rdquo;</em>. By doing so we explicitly limit the number of connections our service
can handle.</p>

<blockquote>
<p>We could, of course, buy more servers, but those cost money and incur many other hidden costs. We might be
particularly reluctant to buy extra servers when we realize that software is the problem, and those servers we
already have are under-utilized.<br />
— R. Pressler</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>This part of the series presented a use case from which we can build upon and
experiment to try various solutions to the problem of blocking calls and scalability.</p>

<p>I hope you understand a little more about blocking calls and context switches after reading this.</p>

<p>In the <a href="../loom-part-3-async">next part</a>, we will take a look at asynchronous calls.</p>

              <hr>
              <p>This blog uses <a target="_blank" href="https://web.hypothes.is/">Hypothesis</a> for public and private (group) comments.</p>
              <p>You can <em>annotate</em> or <em>highlight</em> words or paragraphs directly by selecting the text!</p>
              <p>If you want to leave a general comment or read what others have to say, please use the collapsible panel on the right of this page.</p>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
                
                
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        December 23, 2019
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/loom-part-3-async/">Loom - Part 3 - Asynchronous code</a></strong>
                      </h6>
                    </div>
                  </div>
                
                
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        December 14, 2019
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/loom-part-1-scheduling/">Loom - Part 1 - It&rsquo;s all about Scheduling</a></strong>
                      </h6>
                    </div>
                  </div>
                
                
              </div>
            </div>
          </div>
          <hr>
        <!-- Hypothes.is -->
<script type="application/json" class="js-hypothesis-config">
    {"showHighlights": false}
</script>
<script src="https://hypothes.is/embed.js" async></script>
        </div>
      </div>
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/arnaudbos/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>

<div class="scroll-to-top">
  <a href="#">Scroll<br>to Top</a>
</div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://i-rant.arnaudbos.com/js/docs.min.js"></script>
<script src="https://i-rant.arnaudbos.com/js/main.js"></script>

<script src="https://i-rant.arnaudbos.com/js/ie10-viewport-bug-workaround.js"></script>

<!-- EmojiOne -->
<script src="https://cdn.jsdelivr.net/emojione/2.2.7/lib/js/emojione.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/emojione/2.2.7/assets/css/emojione.min.css"/>

<script>
(function (){
  var emojis = document.getElementsByClassName('emoji');
  for(var i=0; i<emojis.length; i++){
	  var content = emojis[i].textContent;
    emojis[i].innerHTML = emojione.shortnameToImage(content);
  }
})();
</script>

<!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/languages/clojure.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<link rel="stylesheet" href="/css/photoswipe.css">
<link rel="stylesheet" href="/css/default-skin/default-skin.css">
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>
<script src="/js/initphotoswipe.js"></script>



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<style>
    .gallery { float: right; margin-bottom: 10px; text-align: center; }
    .gallery img { height: auto; }
    .gallery .title { text-align: center; text-decoration: underline; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; }
    .gallery figcaption { display: none; }
</style>

<script>initPhotoSwipeFromDOM('.gallery');</script>







  </body>
</html>
